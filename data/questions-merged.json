[
  {
    "question": "Quel est le rôle principal du langage SQL ?",
    "correct": "Communiquer avec une base de données",
    "incorrect": [
      "Crypter les données utilisateurs",
      "Créer des interfaces graphiques",
      "Gérer les connexions réseau"
    ]
  },
  {
    "question": "Quelle commande SQL permet de lire des données dans une base ?",
    "correct": "SELECT",
    "incorrect": [
      "INSERT INTO",
      "DELETE",
      "DROP TABLE"
    ]
  },
  {
    "question": "Quelle commande SQL est utilisée pour insérer des données ?",
    "correct": "INSERT INTO",
    "incorrect": [
      "UPDATE",
      "COUNT()",
      "SELECT"
    ]
  },
  {
    "question": "Quelle commande permet de supprimer complètement une table dans une base SQL ?",
    "correct": "DROP TABLE",
    "incorrect": [
      "DELETE",
      "TRUNCATE",
      "REMOVE TABLE"
    ]
  },
  {
    "question": "Quelle fonction SQL permet de calculer la moyenne d’une colonne numérique ?",
    "correct": "AVG()",
    "incorrect": [
      "SUM()",
      "COUNT()",
      "MAX()"
    ]
  },
  {
    "question": "Quel est un exemple de système de gestion de base de données relationnelle ?",
    "correct": "PostgreSQL",
    "incorrect": [
      "Redis",
      "Cassandra",
      "MongoDB"
    ]
  },
  {
    "question": "Quel type de SGBD est représenté par Cassandra ou MongoDB ?",
    "correct": "SGBD NoSQL",
    "incorrect": [
      "SGBD relationnel",
      "SGBD transactionnel",
      "SGBD distribué"
    ]
  },
  {
    "question": "Parmi les logiciels suivants, lequel est un SGBD relationnel ?",
    "correct": "MySQL",
    "incorrect": [
      "Redis",
      "Elasticsearch",
      "Neo4j"
    ]
  },
  {
    "question": "Quelle est l’une des clés pour optimiser les performances d’une base de données ?",
    "correct": "Faire de bons choix dans la structure de la base",
    "incorrect": [
      "Utiliser uniquement la commande SELECT",
      "Éviter les jointures entre tables",
      "Supprimer les index"
    ]
  },
  {
    "question": "Quel est le rôle du mot-clé FROM dans une requête SQL ?",
    "correct": "Indiquer la table dans laquelle chercher les données",
    "incorrect": [
      "Filtrer les résultats obtenus",
      "Ajouter une condition de tri",
      "Limiter le nombre de résultats"
    ]
  },
  {
    "question": "Quelle requête permet d’obtenir toutes les villes depuis la table client ?",
    "correct": "SELECT ville FROM client",
    "incorrect": [
      "SELECT ville IN client",
      "GET ville FROM client",
      "SELECT client FROM ville"
    ]
  },
  {
    "question": "Comment sélectionner plusieurs colonnes avec une seule requête SELECT ?",
    "correct": "En séparant les noms de colonnes par une virgule",
    "incorrect": [
      "En utilisant plusieurs requêtes SELECT",
      "En les encadrant avec des crochets",
      "En les mettant entre guillemets"
    ]
  },
  {
    "question": "Quelle est la syntaxe pour afficher toutes les colonnes d’une table ?",
    "correct": "SELECT * FROM nom_de_la_table",
    "incorrect": [
      "SELECT ALL FROM nom_de_la_table",
      "SHOW * FROM nom_de_la_table",
      "SELECT FROM * nom_de_la_table"
    ]
  },
  {
    "question": "Quel mot-clé suit immédiatement SELECT dans une requête SQL ?",
    "correct": "FROM",
    "incorrect": [
      "WHERE",
      "ORDER BY",
      "LIMIT"
    ]
  },
  {
    "question": "Quel mot-clé permet de filtrer les résultats d'une requête SELECT ?",
    "correct": "WHERE",
    "incorrect": [
      "GROUP BY",
      "ORDER BY",
      "OFFSET"
    ]
  },
  {
    "question": "Quel mot-clé est utilisé pour regrouper les résultats d’une requête SELECT ?",
    "correct": "GROUP BY",
    "incorrect": [
      "ORDER BY",
      "HAVING",
      "JOIN"
    ]
  },
  {
    "question": "Quel est le rôle principal de la commande SQL DISTINCT ?",
    "correct": "Éviter les doublons dans les résultats d’une requête",
    "incorrect": [
      "Supprimer des enregistrements de la base",
      "Mettre à jour des colonnes en double",
      "Afficher les résultats par ordre alphabétique"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte d'une requête utilisant DISTINCT ?",
    "correct": "SELECT DISTINCT ma_colonne FROM nom_du_tableau",
    "incorrect": [
      "SELECT ma_colonne DISTINCT FROM nom_du_tableau",
      "DISTINCT SELECT ma_colonne FROM nom_du_tableau",
      "SELECT ma_colonne FROM nom_du_tableau DISTINCT"
    ]
  },
  {
    "question": "Dans quel cas faut-il utiliser DISTINCT dans une requête SQL ?",
    "correct": "Quand une colonne contient des valeurs répétées",
    "incorrect": [
      "Quand la table ne contient qu'une seule colonne",
      "Quand on veut ajouter une contrainte de clé primaire",
      "Quand on veut supprimer des doublons dans la base"
    ]
  },
  {
    "question": "Quel mot-clé remplace DISTINCT dans les requêtes SQL pour Oracle ?",
    "correct": "UNIQUE",
    "incorrect": [
      "DIFFERENT",
      "ONLY",
      "EXCLUSIVE"
    ]
  },
  {
    "question": "Que retourne la requête SELECT DISTINCT prenom FROM client si deux clients ont le même prénom ?",
    "correct": "Une seule fois chaque prénom présent dans la table",
    "incorrect": [
      "Tous les prénoms y compris les doublons",
      "Uniquement les prénoms en double",
      "Aucun prénom si un doublon est détecté"
    ]
  },
  {
    "question": "Quel est l’inconvénient de l’usage excessif de DISTINCT ?",
    "correct": "Il peut affecter les performances si mal utilisé",
    "incorrect": [
      "Il crée des colonnes en double",
      "Il supprime les données de la base",
      "Il empêche l’utilisation de conditions WHERE"
    ]
  },
  {
    "question": "Quelle commande est recommandée à la place de DISTINCT pour des raisons de performance ?",
    "correct": "GROUP BY",
    "incorrect": [
      "ORDER BY",
      "HAVING",
      "JOIN"
    ]
  },
  {
    "question": "Quel est le rôle principal de l’option SQL_NO_CACHE ?",
    "correct": "Empêcher l’utilisation du cache lors de l’exécution d’une requête",
    "incorrect": [
      "Forcer l’enregistrement des résultats en cache",
      "Effacer les résultats précédents de la table",
      "Accélérer automatiquement toutes les requêtes"
    ]
  },
  {
    "question": "Dans quelle commande SQL utilise-t-on SQL_NO_CACHE ?",
    "correct": "SELECT",
    "incorrect": [
      "INSERT",
      "UPDATE",
      "DELETE"
    ]
  },
  {
    "question": "Pourquoi utiliser SQL_NO_CACHE lors de tests de performances ?",
    "correct": "Pour mesurer le temps réel de traitement sans influence du cache",
    "incorrect": [
      "Pour trier les résultats plus rapidement",
      "Pour stocker les résultats en mémoire",
      "Pour éviter d’utiliser la base de données principale"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte pour utiliser SQL_NO_CACHE ?",
    "correct": "SELECT SQL_NO_CACHE * FROM table;",
    "incorrect": [
      "SELECT * SQL_NO_CACHE FROM table;",
      "SQL_NO_CACHE SELECT * FROM table;",
      "SELECT * FROM SQL_NO_CACHE table;"
    ]
  },
  {
    "question": "Quelle option SQL a l'effet inverse de SQL_NO_CACHE ?",
    "correct": "SQL_CACHE",
    "incorrect": [
      "USE_CACHE",
      "CACHE_RESULT",
      "ENABLE_CACHE"
    ]
  },
  {
    "question": "Dans quel cas SQL_NO_CACHE est-il particulièrement utile ?",
    "correct": "Quand une requête est lente et doit être optimisée",
    "incorrect": [
      "Quand on veut supprimer des doublons",
      "Quand on veut créer une nouvelle table",
      "Quand on veut appliquer une condition WHERE"
    ]
  },
  {
    "question": "Que fait la fonction NOW() dans l’exemple SELECT *, NOW() FROM table ?",
    "correct": "Ajoute la date et l’heure actuelle aux résultats",
    "incorrect": [
      "Met en pause l’exécution de la requête",
      "Remplace les champs vides par la date",
      "Trie les résultats par date"
    ]
  },
  {
    "question": "Pourquoi la fonction NOW() empêche-t-elle l'utilisation du cache ?",
    "correct": "Parce qu’elle rend chaque requête unique dans le temps",
    "incorrect": [
      "Parce qu’elle vide le cache manuellement",
      "Parce qu’elle utilise un autre moteur de base",
      "Parce qu’elle interrompt les opérations de cache"
    ]
  },
  {
    "question": "À quoi sert la clause WHERE dans une requête SQL ?",
    "correct": "À filtrer les lignes selon une condition",
    "incorrect": [
      "À trier les résultats",
      "À grouper les résultats similaires",
      "À supprimer les lignes vides"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte d’une requête utilisant WHERE ?",
    "correct": "SELECT nom_colonnes FROM nom_table WHERE condition",
    "incorrect": [
      "SELECT WHERE condition FROM nom_table",
      "WHERE SELECT nom_colonnes FROM nom_table",
      "SELECT nom_table FROM nom_colonnes WHERE condition"
    ]
  },
  {
    "question": "Quelle requête permet de sélectionner les clients vivant à Paris ?",
    "correct": "SELECT * FROM client WHERE ville = 'paris'",
    "incorrect": [
      "SELECT * WHERE ville = 'paris' FROM client",
      "SELECT client WHERE ville = 'paris'",
      "FROM client SELECT * WHERE ville = 'paris'"
    ]
  },
  {
    "question": "Quel est l’effet de la casse dans une condition WHERE ?",
    "correct": "Elle peut influencer les résultats si la table est sensible à la casse",
    "incorrect": [
      "Elle est toujours ignorée",
      "Elle est obligatoire dans toutes les requêtes",
      "Elle n’est prise en compte que pour les chiffres"
    ]
  },
  {
    "question": "Quel opérateur SQL signifie 'différent de' ?",
    "correct": "<>",
    "incorrect": [
      "><",
      "==",
      "!=="
    ]
  },
  {
    "question": "Quel opérateur est utilisé pour chercher une valeur dans une liste ?",
    "correct": "IN",
    "incorrect": [
      "BETWEEN",
      "LIKE",
      "IS"
    ]
  },
  {
    "question": "Quel opérateur SQL permet de tester si une valeur est comprise dans un intervalle ?",
    "correct": "BETWEEN",
    "incorrect": [
      "LIKE",
      "RANGE",
      "INSIDE"
    ]
  },
  {
    "question": "Quelle condition permet de sélectionner uniquement les lignes où une valeur est nulle ?",
    "correct": "IS NULL",
    "incorrect": [
      "EQUAL NULL",
      "= NULL",
      "IS VOID"
    ]
  },
  {
    "question": "Quel opérateur permet de rechercher une valeur partielle dans un texte ?",
    "correct": "LIKE",
    "incorrect": [
      "CONTAINS",
      "SEARCH",
      "FIND"
    ]
  },
  {
    "question": "Quel opérateur SQL n’est PAS standard et peut ne pas être reconnu par tous les SGBD ?",
    "correct": "!= (inégalité)",
    "incorrect": [
      "= (égalité)",
      "IN (liste de valeurs)",
      "<= (inférieur ou égal)"
    ]
  },
  {
    "question": "Quel est le rôle de l’opérateur AND dans une requête SQL ?",
    "correct": "Vérifier que deux conditions sont toutes les deux vraies",
    "incorrect": [
      "Vérifier qu’une des deux conditions est vraie",
      "Ignorer les doublons dans les résultats",
      "Compter le nombre de conditions"
    ]
  },
  {
    "question": "Quel est le rôle de l’opérateur OR dans une requête SQL ?",
    "correct": "Vérifier qu’au moins une des deux conditions est vraie",
    "incorrect": [
      "Vérifier que toutes les conditions sont fausses",
      "Filtrer uniquement les valeurs numériques",
      "Exclure les lignes contenant NULL"
    ]
  },
  {
    "question": "Quelle requête affiche les produits de catégorie 'informatique' ayant moins de 20 unités en stock ?",
    "correct": "SELECT * FROM produit WHERE categorie = 'informatique' AND stock < 20",
    "incorrect": [
      "SELECT * FROM produit WHERE categorie = 'informatique' OR stock < 20",
      "SELECT * FROM produit WHERE stock < 20",
      "SELECT * FROM produit AND categorie = 'informatique' < 20"
    ]
  },
  {
    "question": "Quelle requête retourne les produits nommés 'ordinateur' ou 'clavier' ?",
    "correct": "SELECT * FROM produit WHERE nom = 'ordinateur' OR nom = 'clavier'",
    "incorrect": [
      "SELECT * FROM produit WHERE nom = 'ordinateur' AND nom = 'clavier'",
      "SELECT * FROM produit WHERE nom IN ('ordinateur' AND 'clavier')",
      "SELECT * FROM produit OR nom = 'ordinateur' OR nom = 'clavier'"
    ]
  },
  {
    "question": "Quelle est la requête correcte pour sélectionner les produits 'informatique' avec stock < 20 OU 'fourniture' avec stock < 200 ?",
    "correct": "SELECT * FROM produit WHERE (categorie = 'informatique' AND stock < 20) OR (categorie = 'fourniture' AND stock < 200)",
    "incorrect": [
      "SELECT * FROM produit WHERE categorie = 'informatique' AND stock < 20 OR categorie = 'fourniture' AND stock < 200",
      "SELECT * FROM produit WHERE categorie = 'informatique' OR stock < 20 AND categorie = 'fourniture'",
      "SELECT * FROM produit WHERE categorie = 'informatique' AND stock < 20 AND categorie = 'fourniture' AND stock < 200"
    ]
  },
  {
    "question": "Quelle est une bonne pratique lors de l'utilisation combinée de AND et OR ?",
    "correct": "Utiliser des parenthèses pour clarifier la logique",
    "incorrect": [
      "Toujours commencer par les conditions OR",
      "Utiliser uniquement OR pour éviter les erreurs",
      "Supprimer les parenthèses pour simplifier le code"
    ]
  },
  {
    "question": "Quel mot-clé SQL permet de vérifier si une colonne correspond à plusieurs valeurs spécifiques ?",
    "correct": "IN",
    "incorrect": [
      "LIKE",
      "BETWEEN",
      "ALL"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte d’une requête SQL utilisant IN ?",
    "correct": "SELECT colonne FROM table WHERE colonne IN (valeur1, valeur2)",
    "incorrect": [
      "SELECT colonne IN (valeur1, valeur2) FROM table",
      "SELECT colonne FROM table IN (valeur1, valeur2)",
      "WHERE colonne = valeur1 OR valeur2 FROM table"
    ]
  },
  {
    "question": "Que retourne la requête : SELECT * FROM adresse WHERE addr_ville IN ('Paris', 'Graimbouville') ?",
    "correct": "Toutes les adresses situées à Paris ou Graimbouville",
    "incorrect": [
      "Toutes les adresses sauf celles de Paris ou Graimbouville",
      "Seulement les adresses contenant 'Rue'",
      "Toutes les adresses avec un code postal supérieur à 75000"
    ]
  },
  {
    "question": "Quelle requête est équivalente à : SELECT prenom FROM utilisateur WHERE prenom IN ('Maurice', 'Marie') ?",
    "correct": "SELECT prenom FROM utilisateur WHERE prenom = 'Maurice' OR prenom = 'Marie'",
    "incorrect": [
      "SELECT prenom FROM utilisateur WHERE prenom LIKE ('Maurice', 'Marie')",
      "SELECT prenom IN ('Maurice', 'Marie') FROM utilisateur",
      "SELECT prenom FROM utilisateur WHERE prenom = ('Maurice' AND 'Marie')"
    ]
  },
  {
    "question": "Que permet l’utilisation de NOT IN dans une requête SQL ?",
    "correct": "Exclure les lignes correspondant aux valeurs données",
    "incorrect": [
      "Inclure uniquement les valeurs nulles",
      "Trier les résultats inversément",
      "Afficher uniquement les doublons"
    ]
  },
  {
    "question": "Combien de valeurs peut-on mettre dans la clause IN ?",
    "correct": "Autant que nécessaire, il n’y a pas de limite fixée",
    "incorrect": [
      "Seulement deux",
      "Maximum cinq",
      "Exactement dix"
    ]
  },
  {
    "question": "Quel type de données peut-on utiliser avec IN ?",
    "correct": "Des valeurs de tout type compatible avec la colonne ciblée",
    "incorrect": [
      "Uniquement des entiers",
      "Uniquement des chaînes de caractères",
      "Uniquement des dates"
    ]
  },
  {
    "question": "Quel est le rôle principal de l’opérateur SQL BETWEEN ?",
    "correct": "Filtrer les résultats compris dans un intervalle",
    "incorrect": [
      "Ajouter une condition obligatoire",
      "Trier les résultats par ordre croissant",
      "Afficher uniquement les valeurs nulles"
    ]
  },
  {
    "question": "Quel type de données peut-on filtrer avec BETWEEN ?",
    "correct": "Des chaînes de caractères, des nombres ou des dates",
    "incorrect": [
      "Uniquement des chaînes de caractères",
      "Uniquement des nombres entiers",
      "Uniquement des booléens"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte d’une requête utilisant BETWEEN ?",
    "correct": "SELECT * FROM table WHERE colonne BETWEEN valeur1 AND valeur2",
    "incorrect": [
      "SELECT * FROM table BETWEEN colonne valeur1 AND valeur2",
      "SELECT colonne BETWEEN valeur1 AND valeur2 FROM table",
      "SELECT * WHERE colonne = valeur1 TO valeur2 FROM table"
    ]
  },
  {
    "question": "Que retourne la requête : SELECT * FROM utilisateur WHERE date_inscription BETWEEN '2012-04-01' AND '2012-04-20' ?",
    "correct": "Les utilisateurs inscrits entre le 1er et le 20 avril 2012",
    "incorrect": [
      "Les utilisateurs inscrits avant le 1er avril 2012",
      "Tous les utilisateurs inscrits en 2012",
      "Les utilisateurs inscrits uniquement le 20 avril 2012"
    ]
  },
  {
    "question": "Comment exclure un intervalle en SQL ?",
    "correct": "En utilisant NOT BETWEEN",
    "incorrect": [
      "En utilisant EXCLUDE",
      "En ajoutant une clause ELSE",
      "En combinant AND et OR"
    ]
  },
  {
    "question": "Que retourne la requête : SELECT * FROM utilisateur WHERE id NOT BETWEEN 4 AND 10 ?",
    "correct": "Les utilisateurs dont l’id est inférieur à 4 ou supérieur à 10",
    "incorrect": [
      "Tous les utilisateurs ayant un id entre 4 et 10",
      "Aucun utilisateur",
      "Uniquement les utilisateurs ayant un id égal à 4 ou 10"
    ]
  },
  {
    "question": "Que faut-il vérifier lorsqu'on utilise BETWEEN avec différents SGBD ?",
    "correct": "Si les bornes de l’intervalle sont incluses ou non",
    "incorrect": [
      "Si l’intervalle est limité à deux valeurs maximum",
      "Si les noms de colonnes doivent être en majuscules",
      "Si les valeurs doivent être triées automatiquement"
    ]
  },
  {
    "question": "Quel est le rôle principal de l’opérateur SQL LIKE ?",
    "correct": "Rechercher des valeurs correspondant à un modèle",
    "incorrect": [
      "Trier les valeurs par ordre alphabétique",
      "Filtrer les valeurs numériques uniquement",
      "Remplacer une valeur par une autre"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte pour utiliser LIKE dans une requête ?",
    "correct": "SELECT * FROM table WHERE colonne LIKE 'modèle'",
    "incorrect": [
      "SELECT * LIKE 'modèle' FROM table WHERE colonne",
      "SELECT colonne FROM table LIKE 'modèle'",
      "SELECT * FROM table WHERE LIKE colonne = 'modèle'"
    ]
  },
  {
    "question": "Quel caractère wildcard représente zéro, un ou plusieurs caractères ?",
    "correct": "%",
    "incorrect": [
      "_",
      "*",
      "#"
    ]
  },
  {
    "question": "Quel caractère wildcard représente un seul caractère ?",
    "correct": "_",
    "incorrect": [
      "%",
      "*",
      "^"
    ]
  },
  {
    "question": "Quelle requête retourne les villes commençant par la lettre 'N' ?",
    "correct": "SELECT * FROM client WHERE ville LIKE 'N%'",
    "incorrect": [
      "SELECT * FROM client WHERE ville LIKE '%N'",
      "SELECT * FROM client WHERE ville = 'N*'",
      "SELECT * FROM client WHERE ville = 'N'"
    ]
  },
  {
    "question": "Quelle requête retourne les villes qui se terminent par la lettre 'e' ?",
    "correct": "SELECT * FROM client WHERE ville LIKE '%e'",
    "incorrect": [
      "SELECT * FROM client WHERE ville LIKE 'e%'",
      "SELECT * FROM client WHERE ville = '%e'",
      "SELECT * FROM client WHERE ville LIKE 'e*'"
    ]
  },
  {
    "question": "Quelle requête retourne les chaînes contenant la lettre 'a' ?",
    "correct": "SELECT * FROM table WHERE colonne LIKE '%a%'",
    "incorrect": [
      "SELECT * FROM table WHERE colonne = '%a%'",
      "SELECT * FROM table WHERE colonne LIKE 'a%'",
      "SELECT * FROM table WHERE colonne IN ('a')"
    ]
  },
  {
    "question": "Quel modèle permet de trouver les mots commençant par 'pa' et se terminant par 'on' ?",
    "correct": "LIKE 'pa%on'",
    "incorrect": [
      "LIKE '%paon'",
      "LIKE 'pa_on'",
      "LIKE 'pa&on'"
    ]
  },
  {
    "question": "Quel résultat est retourné par le modèle LIKE 'a_c' ?",
    "correct": "Des chaînes de trois lettres commençant par 'a' et finissant par 'c'",
    "incorrect": [
      "Toutes les chaînes contenant un 'a' et un 'c'",
      "Uniquement les chaînes de deux lettres",
      "Les chaînes commençant par 'ac'"
    ]
  },
  {
    "question": "Quel est le résultat de la requête : SELECT * FROM utilisateur WHERE email LIKE '%@example.com' ?",
    "correct": "Les utilisateurs dont l’email se termine par @example.com",
    "incorrect": [
      "Les utilisateurs dont l’email commence par @example.com",
      "Les utilisateurs ayant un domaine d’email vide",
      "Les utilisateurs dont l’adresse email contient uniquement 'example'"
    ]
  },
  {
    "question": "Quelle requête permet de chercher les utilisateurs inscrits en septembre 2018 ?",
    "correct": "SELECT * FROM utilisateur WHERE date_inscription LIKE '2018-09-%'",
    "incorrect": [
      "SELECT * FROM utilisateur WHERE date_inscription LIKE '%2018-09%'",
      "SELECT * FROM utilisateur WHERE date_inscription = '2018-09-*'",
      "SELECT * FROM utilisateur WHERE date_inscription = '09/2018'"
    ]
  },
  {
    "question": "Quelle requête permet de trouver une valeur dont le deuxième caractère est 'a' ?",
    "correct": "SELECT * FROM table WHERE colonne LIKE '_a%'",
    "incorrect": [
      "SELECT * FROM table WHERE colonne LIKE 'a_%'",
      "SELECT * FROM table WHERE colonne LIKE 'a__%'",
      "SELECT * FROM table WHERE colonne LIKE '%a%'"
    ]
  },
  {
    "question": "Pourquoi ne faut-il pas confondre les wildcards SQL avec l’astérisque (*) dans SELECT * ?",
    "correct": "Car l’astérisque dans SELECT * sert à sélectionner toutes les colonnes, pas à remplacer des caractères",
    "incorrect": [
      "Parce que l’astérisque est un opérateur de comparaison",
      "Parce qu’il est réservé aux jointures entre tables",
      "Parce qu’il sert uniquement avec des fonctions d’agrégation"
    ]
  },
  {
    "question": "Quel est le rôle de l’opérateur IS NULL en SQL ?",
    "correct": "Filtrer les lignes dont la valeur est inconnue (NULL)",
    "incorrect": [
      "Comparer deux colonnes entre elles",
      "Supprimer les enregistrements en double",
      "Trier les résultats par ordre alphabétique"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte pour sélectionner les lignes où une colonne est NULL ?",
    "correct": "SELECT * FROM table WHERE nom_colonne IS NULL",
    "incorrect": [
      "SELECT * FROM table WHERE nom_colonne = NULL",
      "SELECT * FROM table WHERE IS NULL nom_colonne",
      "SELECT * FROM table WHERE nom_colonne == NULL"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte pour sélectionner les lignes où une colonne n’est pas NULL ?",
    "correct": "SELECT * FROM table WHERE nom_colonne IS NOT NULL",
    "incorrect": [
      "SELECT * FROM table WHERE nom_colonne != NULL",
      "SELECT * FROM table WHERE nom_colonne <> NULL",
      "SELECT * FROM table WHERE NOT NULL nom_colonne"
    ]
  },
  {
    "question": "Pourquoi les opérateurs classiques (=, <, >, !=) ne fonctionnent-ils pas avec la valeur NULL ?",
    "correct": "Parce que NULL représente une valeur inconnue",
    "incorrect": [
      "Parce que NULL est une chaîne vide",
      "Parce que NULL est toujours égal à zéro",
      "Parce que NULL est un mot-clé réservé"
    ]
  },
  {
    "question": "Quelle requête permet de sélectionner les utilisateurs sans adresse de livraison ?",
    "correct": "SELECT * FROM utilisateur WHERE fk_adresse_livraison_id IS NULL",
    "incorrect": [
      "SELECT * FROM utilisateur WHERE fk_adresse_livraison_id = NULL",
      "SELECT * FROM utilisateur WHERE fk_adresse_livraison_id == 0",
      "SELECT * FROM utilisateur WHERE NOT fk_adresse_livraison_id"
    ]
  },
  {
    "question": "Quelle requête permet d’obtenir uniquement les utilisateurs ayant une adresse de livraison ?",
    "correct": "SELECT * FROM utilisateur WHERE fk_adresse_livraison_id IS NOT NULL",
    "incorrect": [
      "SELECT * FROM utilisateur WHERE fk_adresse_livraison_id != NULL",
      "SELECT * FROM utilisateur WHERE fk_adresse_livraison_id > 0",
      "SELECT * FROM utilisateur WHERE fk_adresse_livraison_id IS DEFINED"
    ]
  },
  {
    "question": "Que retourne l’opérateur IS dans une requête SQL ?",
    "correct": "Une valeur booléenne (TRUE ou FALSE)",
    "incorrect": [
      "Un nombre entier",
      "Une chaîne de texte",
      "Un identifiant unique"
    ]
  },
  {
    "question": "Dans quel contexte utilise-t-on fréquemment IS NULL ?",
    "correct": "Pour tester les colonnes optionnelles ou les relations manquantes",
    "incorrect": [
      "Pour chiffrer des données",
      "Pour forcer la mise à jour d’une ligne",
      "Pour créer des index automatiquement"
    ]
  },
  {
    "question": "Quel est le rôle principal de la commande SQL GROUP BY ?",
    "correct": "Regrouper les lignes ayant une même valeur pour effectuer des calculs sur des groupes",
    "incorrect": [
      "Trier les lignes dans un ordre défini",
      "Filtrer uniquement les lignes nulles",
      "Supprimer les doublons d’une table"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte d’une requête utilisant GROUP BY ?",
    "correct": "SELECT colonne1, fonction(colonne2) FROM table GROUP BY colonne1",
    "incorrect": [
      "SELECT colonne1 FROM table GROUP BY colonne2, fonction(colonne1)",
      "GROUP BY colonne1 SELECT colonne2 FROM table",
      "SELECT colonne1 GROUP BY colonne2 FROM table"
    ]
  },
  {
    "question": "Quelle fonction est utilisée avec GROUP BY pour additionner des valeurs ?",
    "correct": "SUM()",
    "incorrect": [
      "ADD()",
      "TOTAL()",
      "PLUS()"
    ]
  },
  {
    "question": "Dans quel ordre doivent apparaître les clauses WHERE, GROUP BY et HAVING ?",
    "correct": "WHERE, puis GROUP BY, puis HAVING",
    "incorrect": [
      "GROUP BY, puis WHERE, puis HAVING",
      "HAVING, puis WHERE, puis GROUP BY",
      "WHERE, puis HAVING, puis GROUP BY"
    ]
  },
  {
    "question": "Quelle requête permet de connaître le total des achats par client ?",
    "correct": "SELECT client, SUM(tarif) FROM achat GROUP BY client",
    "incorrect": [
      "SELECT SUM(tarif), client FROM achat WHERE client GROUP BY tarif",
      "SELECT tarif, client FROM achat GROUP client BY SUM()",
      "GROUP BY client SELECT tarif FROM achat"
    ]
  },
  {
    "question": "Quelle fonction permet de connaître le nombre d’achats réalisés par client ?",
    "correct": "COUNT()",
    "incorrect": [
      "NUMBER()",
      "TOTAL()",
      "QUANTITY()"
    ]
  },
  {
    "question": "Quelle fonction permet de connaître le prix moyen des achats pour chaque client ?",
    "correct": "AVG()",
    "incorrect": [
      "MEAN()",
      "AVERAGE()",
      "MEDIAN()"
    ]
  },
  {
    "question": "Quelle fonction d’agrégation retourne la plus grande valeur ?",
    "correct": "MAX()",
    "incorrect": [
      "TOP()",
      "HIGHEST()",
      "BIGGEST()"
    ]
  },
  {
    "question": "Quelle fonction permet de récupérer la plus petite valeur dans un groupe ?",
    "correct": "MIN()",
    "incorrect": [
      "LOWEST()",
      "SMALL()",
      "BOTTOM()"
    ]
  },
  {
    "question": "Que se passe-t-il si l’on omet GROUP BY dans une requête avec une fonction d’agrégation ?",
    "correct": "Les résultats ne seront pas regroupés et pourront apparaître en doublon",
    "incorrect": [
      "Une erreur est systématiquement générée",
      "La fonction d’agrégation est ignorée",
      "Seules les lignes contenant des NULL sont affichées"
    ]
  },
  {
    "question": "Quel est le rôle principal de la clause WITH ROLLUP en SQL ?",
    "correct": "Ajouter une ligne récapitulative globale aux résultats d’un GROUP BY",
    "incorrect": [
      "Ajouter une colonne supplémentaire dans la table",
      "Exclure les doublons des résultats groupés",
      "Appliquer une fonction de tri automatique"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte pour utiliser WITH ROLLUP avec GROUP BY ?",
    "correct": "GROUP BY colonne1 WITH ROLLUP",
    "incorrect": [
      "ROLLUP BY colonne1",
      "GROUP ROLLUP colonne1",
      "GROUP BY ROLLUP(colonne1)"
    ]
  },
  {
    "question": "Quel type de données la ligne WITH ROLLUP ajoute-t-elle ?",
    "correct": "Des totaux ou agrégats globaux sur tous les groupes",
    "incorrect": [
      "Une moyenne de chaque colonne",
      "Un filtre sur les NULL uniquement",
      "Un tri par ordre décroissant"
    ]
  },
  {
    "question": "Quelle fonction d’agrégation peut être utilisée avec GROUP BY … WITH ROLLUP ?",
    "correct": "SUM()",
    "incorrect": [
      "REPLACE()",
      "JOIN()",
      "DISTINCT()"
    ]
  },
  {
    "question": "Que permet la fonction MIN() dans un GROUP BY … WITH ROLLUP ?",
    "correct": "Obtenir la valeur minimale dans chaque groupe et globalement",
    "incorrect": [
      "Remplacer toutes les valeurs NULL",
      "Exclure les doublons dans les groupes",
      "Ignorer les lignes avec des dates"
    ]
  },
  {
    "question": "Quelle fonction permet d’obtenir la date de la première inscription dans chaque groupe ?",
    "correct": "MIN(date_inscription)",
    "incorrect": [
      "FIRST(date_inscription)",
      "LOW(date_inscription)",
      "START(date_inscription)"
    ]
  },
  {
    "question": "Quelle fonction permet d’obtenir le nombre total de clients ?",
    "correct": "COUNT(*) avec WITH ROLLUP",
    "incorrect": [
      "TOTAL(client)",
      "SUM(client)",
      "MAX(*)"
    ]
  },
  {
    "question": "Quel est l’intérêt d’utiliser WITH ROLLUP dans une application ?",
    "correct": "Fournir un total général sans requête supplémentaire",
    "incorrect": [
      "Optimiser l’ordre d’affichage des résultats",
      "Accélérer les jointures entre tables",
      "Créer automatiquement des index"
    ]
  },
  {
    "question": "À quoi sert la clause HAVING en SQL ?",
    "correct": "À filtrer les groupes après une agrégation",
    "incorrect": [
      "À filtrer les lignes avant un tri",
      "À renommer des colonnes dans le résultat",
      "À supprimer les lignes en double"
    ]
  },
  {
    "question": "Quelle est la principale différence entre WHERE et HAVING ?",
    "correct": "HAVING s’utilise avec les fonctions d’agrégation comme SUM(), COUNT(), etc.",
    "incorrect": [
      "WHERE permet de grouper les résultats",
      "HAVING trie automatiquement les données",
      "WHERE est plus lent que HAVING"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte d'une requête utilisant HAVING avec GROUP BY ?",
    "correct": "SELECT colonne1, SUM(colonne2) FROM table GROUP BY colonne1 HAVING SUM(colonne2) > valeur",
    "incorrect": [
      "SELECT colonne1, SUM(colonne2) FROM table HAVING SUM(colonne2) > valeur GROUP BY colonne1",
      "SELECT colonne1 FROM table HAVING colonne2 > valeur GROUP BY colonne1",
      "SELECT colonne1 GROUP BY colonne1 HAVING SUM(colonne2) > valeur FROM table"
    ]
  },
  {
    "question": "Que permet la clause HAVING SUM(tarif) > 40 ?",
    "correct": "Afficher uniquement les groupes dont la somme des tarifs est supérieure à 40",
    "incorrect": [
      "Afficher uniquement les tarifs supérieurs à 40 sans regroupement",
      "Trier les tarifs du plus grand au plus petit",
      "Afficher tous les tarifs inférieurs à 40"
    ]
  },
  {
    "question": "Quelle fonction ne peut pas être utilisée seule avec WHERE mais fonctionne avec HAVING ?",
    "correct": "AVG()",
    "incorrect": [
      "IN",
      "LIKE",
      "="
    ]
  },
  {
    "question": "Quel est l'effet de HAVING COUNT(*) > 1 dans une requête ?",
    "correct": "Afficher uniquement les groupes contenant plus d'une ligne",
    "incorrect": [
      "Afficher les lignes avec des valeurs nulles",
      "Afficher les lignes sans doublons",
      "Afficher uniquement les lignes dont la valeur est supérieure à 1"
    ]
  },
  {
    "question": "Quel est le rôle de la commande SQL ORDER BY ?",
    "correct": "Trier les résultats d’une requête selon une ou plusieurs colonnes",
    "incorrect": [
      "Filtrer les doublons dans une table",
      "Regrouper les valeurs identiques dans une colonne",
      "Créer une nouvelle table à partir d’un tri"
    ]
  },
  {
    "question": "Quel est l’ordre de tri par défaut avec ORDER BY ?",
    "correct": "Ordre ascendant",
    "incorrect": [
      "Ordre descendant",
      "Ordre alphabétique inverse",
      "Aucun tri n’est effectué par défaut"
    ]
  },
  {
    "question": "Quelle requête trie les utilisateurs par nom de famille dans l'ordre alphabétique ?",
    "correct": "SELECT * FROM utilisateur ORDER BY nom",
    "incorrect": [
      "SELECT * FROM utilisateur ORDER nom ASC",
      "SELECT * ORDER BY utilisateur.nom",
      "SELECT utilisateur FROM * ORDER BY nom"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte pour trier par deux colonnes, la première en descendant et la seconde en ascendant ?",
    "correct": "ORDER BY colonne1 DESC, colonne2 ASC",
    "incorrect": [
      "ORDER BY colonne1 ASC DESC colonne2",
      "ORDER BY DESC colonne1, colonne2 ASC",
      "ORDER BY colonne1, colonne2 DESC ASC"
    ]
  },
  {
    "question": "Que permet l’ajout du mot-clé DESC après une colonne ?",
    "correct": "Trier les résultats par ordre décroissant",
    "incorrect": [
      "Trier les résultats par ordre aléatoire",
      "Ignorer les valeurs NULL",
      "Filtrer les résultats affichés"
    ]
  },
  {
    "question": "Pourquoi est-il utile de trier sur plusieurs colonnes avec ORDER BY ?",
    "correct": "Pour organiser les résultats secondaires quand des valeurs sont identiques dans la première colonne",
    "incorrect": [
      "Pour forcer l’exécution en parallèle de la requête",
      "Pour éliminer les doublons dans les résultats",
      "Pour appliquer des fonctions d’agrégation plus rapidement"
    ]
  },
  {
    "question": "Quel est le rôle principal de l’instruction SQL AS ?",
    "correct": "Donner un alias temporaire à une colonne ou une table",
    "incorrect": [
      "Appliquer une fonction de tri",
      "Supprimer une colonne d’un résultat",
      "Ajouter une contrainte à une table"
    ]
  },
  {
    "question": "Pourquoi est-il recommandé d’utiliser AS pour les alias ?",
    "correct": "Parce que cela rend la requête plus lisible et respecte le standard ISO",
    "incorrect": [
      "Parce que c’est obligatoire en SQL",
      "Parce que cela permet de créer des index",
      "Parce que cela double les résultats"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte pour renommer la colonne nom_fr en nom ?",
    "correct": "SELECT nom_fr AS nom FROM produit",
    "incorrect": [
      "SELECT AS nom nom_fr FROM produit",
      "SELECT nom_fr nom FROM produit",
      "RENAME nom_fr AS nom FROM produit"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte pour donner un alias à une table ?",
    "correct": "SELECT * FROM produit AS p",
    "incorrect": [
      "SELECT * AS p FROM produit",
      "SELECT * FROM AS produit p",
      "SELECT p FROM produit AS *"
    ]
  },
  {
    "question": "Pourquoi utiliser un alias pour une table dans une requête avec jointure ?",
    "correct": "Pour simplifier la lecture et l’écriture de la requête",
    "incorrect": [
      "Pour désactiver temporairement une table",
      "Pour forcer un tri par ordre alphabétique",
      "Pour renommer définitivement la table dans la base"
    ]
  },
  {
    "question": "Dans l’exemple SELECT p_id, p_nom_fr_fr AS nom, que signifie 'nom' ?",
    "correct": "Un alias donné à la colonne p_nom_fr_fr",
    "incorrect": [
      "Le nom de la table utilisée",
      "Un mot-clé réservé SQL",
      "Une valeur par défaut"
    ]
  },
  {
    "question": "Que permet la requête : SELECT * FROM produit p JOIN produit_categorie pc ON pc.id = p.cat_id ?",
    "correct": "Utiliser des alias pour raccourcir les noms de tables dans une jointure",
    "incorrect": [
      "Créer une table temporaire pour chaque produit",
      "Supprimer les doublons entre les tables",
      "Renommer définitivement les tables dans la base"
    ]
  },
  {
    "question": "Quel est le rôle principal de la clause SQL LIMIT ?",
    "correct": "Limiter le nombre de résultats retournés par une requête",
    "incorrect": [
      "Limiter le nombre de colonnes sélectionnées",
      "Limiter la taille maximale d'une table",
      "Limiter les droits d’un utilisateur sur une table"
    ]
  },
  {
    "question": "Que retourne la requête : SELECT * FROM table LIMIT 10 ?",
    "correct": "Les 10 premiers résultats de la table",
    "incorrect": [
      "Les 10 derniers résultats",
      "10 lignes aléatoires de la table",
      "Les lignes 10 à 20 de la table"
    ]
  },
  {
    "question": "Pourquoi est-il recommandé d’utiliser ORDER BY avec LIMIT ?",
    "correct": "Pour garantir un ordre précis des résultats retournés",
    "incorrect": [
      "Pour pouvoir trier les colonnes par taille",
      "Parce que LIMIT ne fonctionne pas sans tri",
      "Parce que ORDER BY réduit le nombre de lignes"
    ]
  },
  {
    "question": "Que permet la clause OFFSET en SQL ?",
    "correct": "Décaler le point de départ des résultats retournés",
    "incorrect": [
      "Compter le nombre de lignes",
      "Trier les résultats",
      "Ignorer les lignes contenant NULL"
    ]
  },
  {
    "question": "Que fait la requête : SELECT * FROM table LIMIT 10 OFFSET 5 ?",
    "correct": "Retourne les lignes 6 à 15 de la table",
    "incorrect": [
      "Retourne les lignes 5 à 14 de la table",
      "Retourne les 10 dernières lignes de la table",
      "Retourne les lignes 1 à 10 uniquement"
    ]
  },
  {
    "question": "Quelle est une syntaxe MySQL équivalente à LIMIT 10 OFFSET 5 ?",
    "correct": "LIMIT 5, 10",
    "incorrect": [
      "LIMIT OFFSET 5, 10",
      "LIMIT (5 TO 10)",
      "LIMIT 10 START 5"
    ]
  },
  {
    "question": "Pourquoi est-il préférable d’utiliser LIMIT ... OFFSET ... plutôt que LIMIT x, y en MySQL ?",
    "correct": "Pour faciliter la compatibilité avec d’autres SGBD comme PostgreSQL",
    "incorrect": [
      "Parce que cette syntaxe est plus rapide à exécuter",
      "Parce que l’autre syntaxe est obsolète",
      "Parce que LIMIT ne fonctionne pas sans OFFSET"
    ]
  },
  {
    "question": "Quel est l’effet réel de LIMIT sur les performances d’une requête ?",
    "correct": "Il réduit le temps d'affichage mais pas nécessairement le temps d'exécution",
    "incorrect": [
      "Il réduit toujours le temps de traitement de la base",
      "Il accélère la lecture des index",
      "Il évite le chargement des données en mémoire"
    ]
  },
  {
    "question": "Quel est le rôle principal de l’instruction SQL CASE ?",
    "correct": "Effectuer des conditions de type si/sinon dans une requête",
    "incorrect": [
      "Créer une nouvelle table temporaire",
      "Appliquer une jointure automatique",
      "Réinitialiser les valeurs d'une colonne"
    ]
  },
  {
    "question": "Dans quels types de requêtes peut-on utiliser CASE ?",
    "correct": "SELECT, UPDATE, DELETE, WHERE, ORDER BY ou HAVING",
    "incorrect": [
      "Uniquement dans les clauses SELECT et WHERE",
      "Seulement dans les requêtes de création de table",
      "Exclusivement avec des fonctions d’agrégation"
    ]
  },
  {
    "question": "Que retourne une clause CASE si aucune condition n’est remplie et qu’il n’y a pas de ELSE ?",
    "correct": "NULL",
    "incorrect": [
      "La première valeur de la table",
      "Une erreur SQL",
      "Le texte 'aucune correspondance'"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte d’une clause CASE avec comparaison directe de valeur ?",
    "correct": "CASE colonne WHEN valeur THEN résultat ELSE autre END",
    "incorrect": [
      "CASE WHEN colonne = valeur THEN résultat ELSE autre END",
      "IF colonne = valeur THEN résultat ELSE autre",
      "SWITCH colonne (valeur : résultat, ...)"
    ]
  },
  {
    "question": "Dans l’exemple CASE WHEN marge_pourcentage > 1 THEN 'Prix supérieur à la normale', que signifie cette ligne ?",
    "correct": "Elle retourne un message si la marge est supérieure à 1",
    "incorrect": [
      "Elle affiche toujours 'Prix supérieur à la normale'",
      "Elle compare deux colonnes entre elles",
      "Elle supprime les lignes qui ont une marge supérieure à 1"
    ]
  },
  {
    "question": "Comment renvoyer une valeur calculée avec CASE selon une condition ?",
    "correct": "En utilisant THEN suivi d'une expression, comme prix_unitaire * 2",
    "incorrect": [
      "En insérant une requête SELECT à l’intérieur du CASE",
      "En combinant le CASE avec GROUP BY",
      "En utilisant la clause ELSE uniquement"
    ]
  },
  {
    "question": "Quelle clause permet d’utiliser CASE pour mettre à jour les valeurs selon une règle ?",
    "correct": "UPDATE ... SET colonne = CASE ... END",
    "incorrect": [
      "MODIFY ... CASE WHEN",
      "ALTER ... CASE",
      "SET ... UPDATE CASE"
    ]
  },
  {
    "question": "Quel est l’intérêt d’utiliser ELSE dans une clause CASE ?",
    "correct": "Fournir une valeur par défaut si aucune condition n’est remplie",
    "incorrect": [
      "Remplacer toutes les conditions WHEN",
      "Exécuter une sous-requête automatiquement",
      "Créer une nouvelle table en sortie"
    ]
  },
  {
    "question": "Quel est le rôle principal de la commande SQL UNION ?",
    "correct": "Fusionner les résultats de plusieurs requêtes SELECT en supprimant les doublons",
    "incorrect": [
      "Créer une jointure entre deux tables",
      "Mettre à jour deux tables en même temps",
      "Filtrer les lignes contenant des valeurs NULL"
    ]
  },
  {
    "question": "Que se passe-t-il si les deux requêtes SELECT utilisées dans un UNION n'ont pas le même nombre de colonnes ?",
    "correct": "Une erreur est générée",
    "incorrect": [
      "Les colonnes supplémentaires sont ignorées",
      "Les résultats sont tronqués automatiquement",
      "Le résultat sera vide"
    ]
  },
  {
    "question": "Quel mot-clé faut-il utiliser pour inclure les doublons dans une UNION ?",
    "correct": "UNION ALL",
    "incorrect": [
      "UNION DUPLICATE",
      "UNION FULL",
      "UNION DISTINCT"
    ]
  },
  {
    "question": "Pourquoi est-il important que les colonnes soient dans le même ordre lors d'une UNION ?",
    "correct": "Parce que chaque colonne est associée à son homologue par sa position",
    "incorrect": [
      "Parce que le nom des colonnes doit être identique",
      "Parce que cela évite les jointures automatiques",
      "Parce que SQL fusionne les colonnes avec des types différents"
    ]
  },
  {
    "question": "Que retourne cette requête ? SELECT * FROM table1 UNION SELECT * FROM table2",
    "correct": "Tous les enregistrements des deux tables sans doublons",
    "incorrect": [
      "Uniquement les enregistrements communs aux deux tables",
      "Les enregistrements de la première table uniquement",
      "Les enregistrements triés par défaut"
    ]
  },
  {
    "question": "Dans quel cas utiliser UNION est utile par rapport à une jointure ?",
    "correct": "Quand on souhaite concaténer les résultats de deux requêtes ayant la même structure",
    "incorrect": [
      "Quand on veut filtrer les lignes sur une clé primaire",
      "Quand on souhaite comparer des colonnes différentes",
      "Quand on veut fusionner deux bases de données"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte d’une requête utilisant UNION ALL ?",
    "correct": "SELECT * FROM table1 UNION ALL SELECT * FROM table2",
    "incorrect": [
      "SELECT * UNION ALL FROM table1 AND table2",
      "SELECT * FROM table1 JOIN ALL table2",
      "UNION ALL SELECT * FROM table1, table2"
    ]
  },
  {
    "question": "Quelles sont les conditions nécessaires pour utiliser UNION ALL entre deux requêtes ?",
    "correct": "Les deux requêtes doivent avoir le même nombre de colonnes, de même type et dans le même ordre",
    "incorrect": [
      "Les deux requêtes doivent utiliser des noms de colonnes identiques",
      "Les deux tables doivent contenir des clés étrangères",
      "Les deux requêtes doivent être issues de la même table"
    ]
  },
  {
    "question": "Pourquoi UNION ALL est-il utile dans un contexte multi-magasin ?",
    "correct": "Parce qu’il permet de réunir toutes les données, y compris les clients présents dans plusieurs magasins",
    "incorrect": [
      "Parce qu’il supprime automatiquement les doublons de clients",
      "Parce qu’il fusionne les colonnes de manière intelligente",
      "Parce qu’il trie les clients selon leur total d’achats"
    ]
  },
  {
    "question": "Quel est le rôle principal de la commande SQL INTERSECT ?",
    "correct": "Obtenir les enregistrements communs à deux requêtes",
    "incorrect": [
      "Fusionner toutes les lignes de deux tables",
      "Supprimer les doublons entre deux tables",
      "Joindre deux tables sur une clé étrangère"
    ]
  },
  {
    "question": "Quelle est la condition nécessaire pour utiliser INTERSECT entre deux requêtes ?",
    "correct": "Les deux requêtes doivent avoir le même nombre de colonnes, dans le même ordre et avec les mêmes types",
    "incorrect": [
      "Les deux tables doivent avoir une clé primaire commune",
      "Les deux requêtes doivent avoir une clause WHERE",
      "Les deux tables doivent avoir les mêmes noms de colonnes"
    ]
  },
  {
    "question": "Que retourne cette requête : SELECT * FROM table1 INTERSECT SELECT * FROM table2 ?",
    "correct": "Les lignes présentes à la fois dans table1 et table2",
    "incorrect": [
      "Toutes les lignes de table1 et table2, sans doublons",
      "Toutes les lignes de table1 uniquement",
      "Les lignes différentes entre table1 et table2"
    ]
  },
  {
    "question": "Quelle est la différence entre INTERSECT et UNION ?",
    "correct": "INTERSECT retourne les lignes communes, UNION toutes les lignes sans doublons",
    "incorrect": [
      "INTERSECT trie les résultats, UNION ne le fait pas",
      "INTERSECT ne fonctionne qu’avec les jointures",
      "INTERSECT retourne toujours plus de résultats que UNION"
    ]
  },
  {
    "question": "Quelle est l’alternative à INTERSECT pour MySQL ?",
    "correct": "Utiliser une sous-requête avec IN",
    "incorrect": [
      "Utiliser LEFT JOIN avec GROUP BY",
      "Utiliser UNION ALL avec DISTINCT",
      "Utiliser une clause HAVING uniquement"
    ]
  },
  {
    "question": "Que se passe-t-il si une ligne est présente dans les deux tables mais avec une valeur différente dans une seule colonne ?",
    "correct": "Elle n’est pas incluse dans le résultat de l’INTERSECT",
    "incorrect": [
      "Elle est fusionnée automatiquement",
      "Elle est incluse partiellement",
      "Elle est incluse si la majorité des valeurs sont identiques"
    ]
  },
  {
    "question": "Quel est l'équivalent de la commande EXCEPT dans MySQL ?",
    "correct": "MINUS",
    "incorrect": [
      "INTERSECT",
      "UNION",
      "EXCLUDE"
    ]
  },
  {
    "question": "Dans quel cas utilise-t-on EXCEPT ?",
    "correct": "Pour récupérer les lignes de la première requête qui ne sont pas présentes dans la seconde",
    "incorrect": [
      "Pour récupérer les lignes présentes dans les deux requêtes",
      "Pour supprimer des lignes dans une table",
      "Pour trier les résultats selon une condition"
    ]
  },
  {
    "question": "Quelle condition doivent respecter les deux requêtes utilisées avec EXCEPT ?",
    "correct": "Avoir le même nombre de colonnes, les mêmes types de données et dans le même ordre",
    "incorrect": [
      "Utiliser les mêmes noms de colonnes",
      "Utiliser au moins une clé primaire",
      "Utiliser une clause WHERE dans les deux"
    ]
  },
  {
    "question": "Quel est le résultat de cette requête ? SELECT prenom, nom FROM clients_inscrits EXCEPT SELECT prenom, nom FROM clients_refus_email",
    "correct": "Les clients inscrits qui n’ont pas refusé de recevoir des emails",
    "incorrect": [
      "Tous les clients de la base clients_refus_email",
      "Les clients présents dans les deux tables",
      "Tous les clients ayant une date d’inscription"
    ]
  },
  {
    "question": "Quelle commande SQL permet d’insérer des données dans une table ?",
    "correct": "INSERT INTO",
    "incorrect": [
      "UPDATE SET",
      "SELECT INTO",
      "ADD ROW"
    ]
  },
  {
    "question": "Que faut-il respecter lorsqu'on insère une ligne sans spécifier les colonnes ?",
    "correct": "L’ordre des colonnes dans la table",
    "incorrect": [
      "Le type de la première colonne uniquement",
      "Le nom des colonnes dans l’ordre alphabétique",
      "Le tri croissant des valeurs numériques"
    ]
  },
  {
    "question": "Quel est l’avantage de spécifier les colonnes dans une commande INSERT INTO ?",
    "correct": "L’ordre des colonnes n’a pas d’importance",
    "incorrect": [
      "Les données peuvent être insérées en double",
      "Toutes les colonnes doivent être remplies obligatoirement",
      "On peut insérer des données même si la table est verrouillée"
    ]
  },
  {
    "question": "Que faut-il faire pour insérer du texte dans une colonne de type VARCHAR ?",
    "correct": "Mettre le texte entre guillemets simples",
    "incorrect": [
      "Ajouter une virgule après chaque mot",
      "Utiliser des guillemets doubles",
      "Mettre le texte entre crochets"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte pour insérer plusieurs lignes dans une table ?",
    "correct": "INSERT INTO table (col1, col2) VALUES (val1, val2), (val3, val4)",
    "incorrect": [
      "INSERT ALL INTO table VALUES (val1, val2, val3, val4)",
      "INSERT INTO table VALUES SET (val1, val2), (val3, val4)",
      "MULTI INSERT table VALUES (val1, val2), (val3, val4)"
    ]
  },
  {
    "question": "Que se passe-t-il si vous ne remplissez pas toutes les colonnes dans une requête INSERT INTO avec noms de colonnes ?",
    "correct": "Les colonnes non mentionnées prendront leur valeur par défaut",
    "incorrect": [
      "Une erreur est renvoyée",
      "Les colonnes sont automatiquement remplies avec NULL",
      "La requête est ignorée"
    ]
  },
  {
    "question": "Quel type de valeur ne nécessite pas de guillemets dans une requête INSERT INTO ?",
    "correct": "Les entiers (INT)",
    "incorrect": [
      "Les chaînes de caractères",
      "Les dates",
      "Les types TEXT"
    ]
  },
  {
    "question": "Comment insérer une seule ligne dans une table en spécifiant toutes les colonnes ?",
    "correct": "INSERT INTO table VALUES ('val1', 'val2', 3)",
    "incorrect": [
      "INSERT table SET ('val1', 'val2', 3)",
      "INSERT VALUES INTO table ('val1', 'val2', 3)",
      "ADD TO table ('val1', 'val2', 3)"
    ]
  },
  {
    "question": "Pourquoi est-il pratique d’indiquer les noms de colonnes dans INSERT INTO ?",
    "correct": "Parce que cela rend la requête plus flexible en cas de changement de structure de table",
    "incorrect": [
      "Parce que cela permet d’ignorer les erreurs de type",
      "Parce que cela empêche les duplications automatiques",
      "Parce que cela génère des clés primaires automatiquement"
    ]
  },
  {
    "question": "Quel Système de Gestion de Base de Données supporte la clause ON DUPLICATE KEY UPDATE ?",
    "correct": "MySQL",
    "incorrect": [
      "PostgreSQL",
      "SQLite",
      "SQL Server"
    ]
  },
  {
    "question": "Dans quel cas ON DUPLICATE KEY UPDATE ne déclenche-t-il pas d’insertion ?",
    "correct": "Si une ligne avec la même clé primaire existe déjà",
    "incorrect": [
      "Si la table est vide",
      "Si la clause WHERE est absente",
      "Si le champ est en texte"
    ]
  },
  {
    "question": "Quelle commande permet d’ajouter un vote ou de l’incrémenter s’il existe déjà ?",
    "correct": "INSERT INTO vote (...) VALUES (...) ON DUPLICATE KEY UPDATE vote_count = vote_count + 1",
    "incorrect": [
      "UPDATE vote SET vote_count = vote_count + 1 WHERE id = ?",
      "INSERT IGNORE INTO vote (...) VALUES (...)",
      "MERGE INTO vote USING dual ON (...) WHEN MATCHED THEN UPDATE"
    ]
  },
  {
    "question": "Pourquoi est-il conseillé d’utiliser NOW() dans la clause ON DUPLICATE KEY UPDATE ?",
    "correct": "Pour enregistrer la date de dernière mise à jour",
    "incorrect": [
      "Pour éviter les doublons",
      "Pour créer une nouvelle colonne temporaire",
      "Pour définir un identifiant unique"
    ]
  },
  {
    "question": "Quelle est une alternative correcte à ON DUPLICATE KEY UPDATE pour ne rien faire si la ligne existe déjà ?",
    "correct": "ON DUPLICATE KEY UPDATE id = id",
    "incorrect": [
      "ON UPDATE IGNORE",
      "ON INSERT SKIP",
      "UPDATE OR FAIL"
    ]
  },
  {
    "question": "Quelle version minimale de MySQL prend en charge ON DUPLICATE KEY UPDATE ?",
    "correct": "4.1",
    "incorrect": [
      "3.23",
      "5.7",
      "8.0"
    ]
  },
  {
    "question": "Quel est le rôle principal de la commande SQL UPDATE ?",
    "correct": "Modifier des données existantes dans une table",
    "incorrect": [
      "Ajouter une nouvelle colonne dans une table",
      "Supprimer des lignes de la table",
      "Créer une nouvelle table"
    ]
  },
  {
    "question": "Que se passe-t-il si on oublie la clause WHERE dans une commande UPDATE ?",
    "correct": "Toutes les lignes de la table sont modifiées",
    "incorrect": [
      "Une erreur est générée",
      "Aucune ligne n’est modifiée",
      "Seule la première ligne est modifiée"
    ]
  },
  {
    "question": "Quelle est la bonne syntaxe pour modifier plusieurs colonnes dans une requête UPDATE ?",
    "correct": "SET colonne1 = valeur1, colonne2 = valeur2",
    "incorrect": [
      "SET colonne1 TO valeur1 AND colonne2 TO valeur2",
      "UPDATE colonne1 = valeur1; colonne2 = valeur2",
      "MODIFY colonne1 = valeur1, colonne2 = valeur2"
    ]
  },
  {
    "question": "Quelle commande permet de modifier l’adresse du client ayant l’id 2 ?",
    "correct": "UPDATE client SET rue = '49 Rue Ameline' WHERE id = 2",
    "incorrect": [
      "MODIFY client SET rue = '49 Rue Ameline' WHERE id = 2",
      "UPDATE client SET rue = '49 Rue Ameline' IF id = 2",
      "SET rue = '49 Rue Ameline' WHERE id = 2 IN client"
    ]
  },
  {
    "question": "Quelle commande permet de mettre à jour à la fois la ville et le code postal d’un client ?",
    "correct": "UPDATE client SET ville = 'Paris', code_postal = '75001' WHERE id = 1",
    "incorrect": [
      "MODIFY client SET ville AND code_postal = 'Paris', '75001'",
      "UPDATE client SET (ville, code_postal) = ('Paris', '75001')",
      "UPDATE client WHERE id = 1 SET ville = 'Paris', code_postal = '75001'"
    ]
  },
  {
    "question": "Pourquoi est-il recommandé d’utiliser WHERE dans une requête UPDATE ?",
    "correct": "Pour limiter les modifications à certaines lignes",
    "incorrect": [
      "Pour trier les résultats après modification",
      "Pour créer un index temporaire",
      "Pour annuler automatiquement l’opération en cas d’erreur"
    ]
  },
  {
    "question": "Quel est le rôle principal de la commande SQL DELETE ?",
    "correct": "Supprimer des lignes dans une table",
    "incorrect": [
      "Supprimer une table entière",
      "Vider uniquement les colonnes d’une table",
      "Réinitialiser les valeurs des colonnes"
    ]
  },
  {
    "question": "Que se passe-t-il si on exécute DELETE FROM utilisateur sans clause WHERE ?",
    "correct": "Toutes les lignes sont supprimées",
    "incorrect": [
      "Une seule ligne est supprimée",
      "Une erreur est générée",
      "La commande ne fait rien"
    ]
  },
  {
    "question": "Quelle commande supprime tous les utilisateurs inscrits avant le 10 avril 2012 ?",
    "correct": "DELETE FROM utilisateur WHERE date_inscription < '2012-04-10'",
    "incorrect": [
      "REMOVE utilisateur WHERE date_inscription < '2012-04-10'",
      "DELETE utilisateur IF date_inscription < '2012-04-10'",
      "DELETE * FROM utilisateur WHERE date_inscription < '2012-04-10'"
    ]
  },
  {
    "question": "Quelle commande supprime toutes les lignes d’une table et réinitialise l’auto-incrément ?",
    "correct": "TRUNCATE TABLE utilisateur",
    "incorrect": [
      "DELETE FROM utilisateur",
      "RESET TABLE utilisateur",
      "CLEAR utilisateur"
    ]
  },
  {
    "question": "Quelle est la différence principale entre DELETE et TRUNCATE ?",
    "correct": "TRUNCATE réinitialise l’auto-incrément, DELETE non",
    "incorrect": [
      "DELETE est plus rapide que TRUNCATE",
      "TRUNCATE nécessite une clause WHERE",
      "DELETE ne supprime pas vraiment les données"
    ]
  },
  {
    "question": "Comment supprimer un utilisateur dont l’id est 1 ?",
    "correct": "DELETE FROM utilisateur WHERE id = 1",
    "incorrect": [
      "DELETE utilisateur WHERE id IS 1",
      "REMOVE utilisateur WHERE id = 1",
      "DELETE WHERE id = 1 FROM utilisateur"
    ]
  },
  {
    "question": "Que doit-on faire avant d’exécuter une commande DELETE importante ?",
    "correct": "Effectuer une sauvegarde de la base de données",
    "incorrect": [
      "Réinitialiser toutes les tables",
      "Activer le mode lecture seule",
      "Créer une nouvelle base de données"
    ]
  },
  {
    "question": "Quel est le rôle principal de la commande SQL MERGE ?",
    "correct": "Insérer ou mettre à jour des données selon une condition",
    "incorrect": [
      "Fusionner deux tables différentes",
      "Supprimer des enregistrements en double",
      "Compresser une table pour optimiser la base"
    ]
  },
  {
    "question": "Comment appelle-t-on aussi le comportement de MERGE en SQL ?",
    "correct": "Upsert",
    "incorrect": [
      "Joinset",
      "Extract",
      "Rebuild"
    ]
  },
  {
    "question": "Quel mot-clé permet de déclencher une mise à jour dans une commande MERGE ?",
    "correct": "WHEN MATCHED",
    "incorrect": [
      "IF EXISTS",
      "WHEN TRUE",
      "IF NOT NULL"
    ]
  },
  {
    "question": "Quel mot-clé est utilisé pour insérer des données si aucune correspondance n’est trouvée dans MERGE ?",
    "correct": "WHEN NOT MATCHED",
    "incorrect": [
      "ELSE INSERT",
      "IF NEW",
      "WHEN MISSING"
    ]
  },
  {
    "question": "Quel mot-clé dans MERGE permet de définir la table cible ?",
    "correct": "MERGE INTO",
    "incorrect": [
      "INSERT INTO",
      "JOIN INTO",
      "UPDATE SET"
    ]
  },
  {
    "question": "Dans la syntaxe MERGE, quelle clause permet de définir les conditions de correspondance entre deux tables ?",
    "correct": "ON",
    "incorrect": [
      "WHERE",
      "IF",
      "MATCH"
    ]
  },
  {
    "question": "Quelle base de données n’utilise PAS la syntaxe MERGE standard ?",
    "correct": "MySQL",
    "incorrect": [
      "Oracle",
      "SQL Server",
      "DB2"
    ]
  },
  {
    "question": "Dans une commande MERGE, que permet la clause USING ?",
    "correct": "Définir les données sources utilisées pour la comparaison",
    "incorrect": [
      "Créer une nouvelle table de résultats",
      "Filtrer les résultats du SELECT",
      "Spécifier les valeurs d’insertion"
    ]
  },
  {
    "question": "Quel est l’intérêt principal de la commande MERGE ?",
    "correct": "Éviter d’avoir à écrire séparément une requête INSERT et une requête UPDATE",
    "incorrect": [
      "Fusionner deux colonnes dans une table",
      "Créer automatiquement des clés primaires",
      "Ajouter des index à une table existante"
    ]
  },
  {
    "question": "Quel est le rôle principal de la commande TRUNCATE en SQL ?",
    "correct": "Supprimer toutes les données d’une table sans supprimer la table",
    "incorrect": [
      "Supprimer une table et toutes ses données",
      "Réinitialiser les valeurs nulles dans une table",
      "Supprimer uniquement les doublons dans une table"
    ]
  },
  {
    "question": "Quelle est une différence importante entre TRUNCATE et DELETE ?",
    "correct": "TRUNCATE réinitialise l’auto-incrément",
    "incorrect": [
      "DELETE supprime plus rapidement les lignes",
      "TRUNCATE permet de supprimer certaines lignes",
      "DELETE ne peut pas être utilisé sans WHERE"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte pour utiliser TRUNCATE sur une table nommée 'fourniture' ?",
    "correct": "TRUNCATE TABLE `fourniture`",
    "incorrect": [
      "TRUNCATE `fourniture`",
      "DELETE * FROM fourniture",
      "DROP ROWS FROM fourniture"
    ]
  },
  {
    "question": "Pourquoi TRUNCATE est-il souvent plus rapide que DELETE ?",
    "correct": "Car il ne journalise pas chaque suppression de ligne",
    "incorrect": [
      "Car il utilise des index plus rapides",
      "Car il trie les données avant suppression",
      "Car il supprime uniquement les lignes avec des valeurs nulles"
    ]
  },
  {
    "question": "Que faut-il faire avant d’exécuter un TRUNCATE sur une table importante ?",
    "correct": "Faire une sauvegarde de la table ou de la base",
    "incorrect": [
      "Lancer un VACUUM automatique",
      "Exporter uniquement la structure de la base",
      "Supprimer toutes les contraintes de la table"
    ]
  },
  {
    "question": "Le TRUNCATE TABLE est-il compatible avec une clause WHERE ?",
    "correct": "Non, TRUNCATE supprime toujours toutes les lignes",
    "incorrect": [
      "Oui, si la condition est simple",
      "Oui, mais uniquement sur PostgreSQL",
      "Uniquement si une clé primaire est définie"
    ]
  },
  {
    "question": "Quelle est la commande de base pour créer une nouvelle base de données appelée 'ma_base' en SQL ?",
    "correct": "CREATE DATABASE ma_base",
    "incorrect": [
      "NEW DATABASE ma_base",
      "CREATE DB ma_base",
      "INIT DATABASE ma_base"
    ]
  },
  {
    "question": "Que permet l’option IF NOT EXISTS dans la commande CREATE DATABASE ?",
    "correct": "Éviter une erreur si la base existe déjà",
    "incorrect": [
      "Forcer la suppression de l’ancienne base",
      "Créer une sauvegarde de la base existante",
      "Fusionner deux bases de données du même nom"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte pour créer une base uniquement si elle n’existe pas ?",
    "correct": "CREATE DATABASE IF NOT EXISTS ma_base",
    "incorrect": [
      "CREATE DATABASE IF ma_base NOT EXISTS",
      "CREATE IF NOT EXISTS DATABASE ma_base",
      "IF NOT EXISTS CREATE DATABASE ma_base"
    ]
  },
  {
    "question": "Dans le standard SQL, pourquoi la commande CREATE DATABASE peut-elle poser problème ?",
    "correct": "Elle n’est pas définie dans le standard SQL officiel",
    "incorrect": [
      "Elle nécessite toujours des privilèges ROOT",
      "Elle ne permet pas de définir un nom personnalisé",
      "Elle remplace systématiquement une base existante"
    ]
  },
  {
    "question": "Quelle option n’est PAS directement modifiable avec la commande CREATE DATABASE ?",
    "correct": "Le nombre de tables par base",
    "incorrect": [
      "Le jeu de caractères",
      "Le propriétaire de la base",
      "Le nom de la base"
    ]
  },
  {
    "question": "Quel est le rôle de la commande CREATE TABLE en SQL ?",
    "correct": "Définir une nouvelle structure de table avec ses colonnes et types de données",
    "incorrect": [
      "Ajouter des données dans une table existante",
      "Supprimer une table de la base de données",
      "Afficher les lignes d’une table"
    ]
  },
  {
    "question": "Dans la commande CREATE TABLE, à quoi sert le mot-clé PRIMARY KEY ?",
    "correct": "À indiquer qu’une colonne est une clé primaire unique",
    "incorrect": [
      "À trier automatiquement les résultats",
      "À ajouter un champ obligatoire",
      "À créer une clé étrangère"
    ]
  },
  {
    "question": "Que permet l’attribut NOT NULL dans une déclaration de colonne ?",
    "correct": "Empêcher les valeurs nulles dans cette colonne",
    "incorrect": [
      "Empêcher les doublons",
      "Autoriser les valeurs vides",
      "Remplir automatiquement avec une chaîne vide"
    ]
  },
  {
    "question": "Quel mot-clé permet d’assigner une valeur automatique lorsqu’aucune donnée n’est fournie ?",
    "correct": "DEFAULT",
    "incorrect": [
      "AUTO",
      "FILL",
      "AUTOSET"
    ]
  },
  {
    "question": "Quel type de données est adapté pour stocker un code postal de 5 caractères ?",
    "correct": "CHAR(5)",
    "incorrect": [
      "INT(5)",
      "VARCHAR(255)",
      "TEXT"
    ]
  },
  {
    "question": "Que signifie VARCHAR dans une déclaration de colonne ?",
    "correct": "Une chaîne de caractères de longueur variable",
    "incorrect": [
      "Un nombre entier avec décimales",
      "Un type binaire",
      "Une date au format texte"
    ]
  },
  {
    "question": "Quelle est la commande SQL pour supprimer complètement une base de données appelée 'ma_base' ?",
    "correct": "DROP DATABASE ma_base",
    "incorrect": [
      "DELETE DATABASE ma_base",
      "REMOVE DATABASE ma_base",
      "TRUNCATE DATABASE ma_base"
    ]
  },
  {
    "question": "Que permet l’option IF EXISTS dans DROP DATABASE ?",
    "correct": "Ne pas retourner d’erreur si la base n’existe pas",
    "incorrect": [
      "Ignorer les index de la base",
      "Protéger les tables système",
      "Créer la base si elle n’existe pas"
    ]
  },
  {
    "question": "Que faut-il vérifier avant d’exécuter un DROP DATABASE ?",
    "correct": "Que la base n’est plus utilisée et qu’une sauvegarde est disponible",
    "incorrect": [
      "Que la base est vide",
      "Que la table principale est verrouillée",
      "Que toutes les colonnes sont indexées"
    ]
  },
  {
    "question": "Quel est le rôle d’une clé primaire (PRIMARY KEY) dans une table SQL ?",
    "correct": "Identifier de façon unique chaque enregistrement",
    "incorrect": [
      "Autoriser les doublons dans une table",
      "Créer une relation avec une autre base",
      "Indiquer une valeur par défaut"
    ]
  },
  {
    "question": "Combien de clés primaires une table SQL peut-elle contenir ?",
    "correct": "Une seule",
    "incorrect": [
      "Aucune",
      "Autant que nécessaire",
      "Une par colonne"
    ]
  },
  {
    "question": "Que garantit une clé primaire sur les valeurs qu’elle contient ?",
    "correct": "Unicité et absence de valeurs NULL",
    "incorrect": [
      "Présence obligatoire de doublons",
      "Possibilité de stocker des valeurs vides",
      "Tri automatique des enregistrements"
    ]
  },
  {
    "question": "Quel mot-clé est souvent utilisé avec PRIMARY KEY pour générer automatiquement un identifiant ?",
    "correct": "AUTO_INCREMENT",
    "incorrect": [
      "AUTO_FILL",
      "GENERATE_ID",
      "PRIMARY_AUTO"
    ]
  },
  {
    "question": "Quelle syntaxe permet de définir une clé primaire directement sur la colonne 'id' ?",
    "correct": "`id` INT PRIMARY KEY AUTO_INCREMENT",
    "incorrect": [
      "`id` INT AUTO_INCREMENT KEY",
      "`id` PRIMARY AUTO_INCREMENT",
      "`id` UNIQUE NOT NULL PRIMARY KEY"
    ]
  },
  {
    "question": "Quelle est la conséquence de définir PRIMARY KEY sur deux colonnes ?",
    "correct": "Les combinaisons des deux colonnes doivent être uniques",
    "incorrect": [
      "Les deux colonnes auront des valeurs identiques",
      "Une seule des colonnes sera utilisée pour l’unicité",
      "Les colonnes peuvent contenir des doublons"
    ]
  },
  {
    "question": "Quel type de données est le plus couramment utilisé pour une clé primaire auto-incrémentée ?",
    "correct": "INT",
    "incorrect": [
      "VARCHAR",
      "DATE",
      "BOOLEAN"
    ]
  },
  {
    "question": "Que se passe-t-il si vous tentez d’insérer une valeur déjà existante dans une colonne définie comme PRIMARY KEY ?",
    "correct": "Une erreur est générée",
    "incorrect": [
      "La valeur est remplacée automatiquement",
      "La ligne est ignorée",
      "La requête est exécutée sans erreur"
    ]
  },
  {
    "question": "Quel est le rôle de l'attribut AUTO_INCREMENT dans une colonne SQL ?",
    "correct": "Incrémenter automatiquement la valeur de la colonne à chaque nouvel enregistrement",
    "incorrect": [
      "Réinitialiser les valeurs d'une colonne",
      "Créer un identifiant aléatoire",
      "Ajouter automatiquement une date"
    ]
  },
  {
    "question": "Quel type de colonne est le plus souvent utilisé avec AUTO_INCREMENT ?",
    "correct": "INT",
    "incorrect": [
      "VARCHAR",
      "TEXT",
      "BOOLEAN"
    ]
  },
  {
    "question": "Que faut-il faire pour que AUTO_INCREMENT fonctionne correctement sur une colonne ?",
    "correct": "Définir la colonne comme clé primaire",
    "incorrect": [
      "Définir la colonne comme clé étrangère",
      "Lui attribuer une valeur par défaut",
      "La rendre optionnelle"
    ]
  },
  {
    "question": "Quelle est la valeur par défaut de départ pour AUTO_INCREMENT ?",
    "correct": "1",
    "incorrect": [
      "0",
      "10",
      "100"
    ]
  },
  {
    "question": "Quelle requête permet de démarrer l’incrémentation à partir de 50 ?",
    "correct": "ALTER TABLE `nom_de__la_table` AUTO_INCREMENT=50;",
    "incorrect": [
      "SET AUTO_INCREMENT TO 50;",
      "MODIFY AUTO_INCREMENT 50;",
      "ALTER COLUMN AUTO_INCREMENT=50;"
    ]
  },
  {
    "question": "Peut-on utiliser AUTO_INCREMENT sur plusieurs colonnes dans une même table ?",
    "correct": "Non, une seule colonne AUTO_INCREMENT est autorisée par table",
    "incorrect": [
      "Oui, sur toutes les colonnes numériques",
      "Oui, si elles ne sont pas clés primaires",
      "Oui, mais seulement sur les colonnes texte"
    ]
  },
  {
    "question": "Quelle est la commande SQL de base pour modifier la structure d’une table ?",
    "correct": "ALTER TABLE",
    "incorrect": [
      "MODIFY TABLE",
      "UPDATE TABLE",
      "CHANGE TABLE"
    ]
  },
  {
    "question": "Quelle commande permet d’ajouter une colonne 'adresse_rue' à une table 'utilisateur' ?",
    "correct": "ALTER TABLE utilisateur ADD adresse_rue VARCHAR(255);",
    "incorrect": [
      "MODIFY TABLE utilisateur ADD adresse_rue VARCHAR(255);",
      "ALTER TABLE utilisateur INSERT adresse_rue VARCHAR(255);",
      "ALTER utilisateur ADD adresse_rue VARCHAR(255);"
    ]
  },
  {
    "question": "Quelle est la bonne syntaxe pour supprimer une colonne dans une table SQL ?",
    "correct": "ALTER TABLE nom_table DROP nom_colonne;",
    "incorrect": [
      "ALTER TABLE nom_table DELETE nom_colonne;",
      "REMOVE COLUMN FROM nom_table;",
      "ALTER nom_table REMOVE nom_colonne;"
    ]
  },
  {
    "question": "Quelle commande est équivalente à 'DROP nom_colonne' dans ALTER TABLE ?",
    "correct": "DROP COLUMN nom_colonne",
    "incorrect": [
      "REMOVE nom_colonne",
      "DELETE COLUMN nom_colonne",
      "CUT nom_colonne"
    ]
  },
  {
    "question": "En MySQL, quelle syntaxe permet de modifier le type d'une colonne ?",
    "correct": "ALTER TABLE nom_table MODIFY nom_colonne type_donnees;",
    "incorrect": [
      "ALTER TABLE nom_table ALTER nom_colonne type_donnees;",
      "MODIFY TABLE nom_table CHANGE nom_colonne type_donnees;",
      "ALTER COLUMN nom_colonne TYPE type_donnees;"
    ]
  },
  {
    "question": "Quelle est la syntaxe PostgreSQL pour modifier le type d'une colonne ?",
    "correct": "ALTER TABLE nom_table ALTER COLUMN nom_colonne TYPE type_donnees;",
    "incorrect": [
      "ALTER TABLE nom_table MODIFY nom_colonne type_donnees;",
      "ALTER nom_table CHANGE COLUMN nom_colonne TO type_donnees;",
      "MODIFY TABLE nom_table ALTER nom_colonne;"
    ]
  },
  {
    "question": "Quelle est la bonne syntaxe MySQL pour renommer une colonne tout en précisant son type ?",
    "correct": "ALTER TABLE nom_table CHANGE ancien_nom nouveau_nom type_donnees;",
    "incorrect": [
      "ALTER TABLE nom_table RENAME COLUMN ancien_nom TO nouveau_nom type_donnees;",
      "ALTER TABLE nom_table MODIFY COLUMN ancien_nom TO nouveau_nom type_donnees;",
      "ALTER nom_table RENAME COLUMN ancien_nom AS nouveau_nom type_donnees;"
    ]
  },
  {
    "question": "Quelle commande PostgreSQL permet de renommer une colonne ?",
    "correct": "ALTER TABLE nom_table RENAME COLUMN ancien_nom TO nouveau_nom;",
    "incorrect": [
      "ALTER TABLE nom_table CHANGE COLUMN ancien_nom nouveau_nom;",
      "RENAME COLUMN ancien_nom TO nouveau_nom;",
      "ALTER COLUMN nom_table RENAME TO nouveau_nom;"
    ]
  },
  {
    "question": "Que se passe-t-il si vous omettez le type de données lors d’un 'CHANGE' en MySQL ?",
    "correct": "Une erreur est générée",
    "incorrect": [
      "La colonne est supprimée",
      "La colonne est ignorée",
      "Le type de données est conservé automatiquement"
    ]
  },
  {
    "question": "Quelles dépendances doivent être supprimées avant d’utiliser DROP TABLE ?",
    "correct": "Les clés étrangères dépendantes",
    "incorrect": [
      "Les champs numériques",
      "Les index primaires uniquement",
      "Les champs avec valeurs NULL"
    ]
  },
  {
    "question": "Quel est le rôle principal d’une jointure SQL ?",
    "correct": "Associer les données de plusieurs tables dans une même requête",
    "incorrect": [
      "Créer une nouvelle table à partir d’une table existante",
      "Exporter des données vers un autre SGBD",
      "Supprimer les doublons dans une table"
    ]
  },
  {
    "question": "Quelle jointure retourne uniquement les lignes ayant une correspondance dans les deux tables ?",
    "correct": "INNER JOIN",
    "incorrect": [
      "LEFT JOIN",
      "RIGHT JOIN",
      "FULL JOIN"
    ]
  },
  {
    "question": "Quel type de jointure permet de retourner toutes les lignes de la table de gauche, même sans correspondance ?",
    "correct": "LEFT JOIN",
    "incorrect": [
      "INNER JOIN",
      "CROSS JOIN",
      "SELF JOIN"
    ]
  },
  {
    "question": "Quelle jointure retourne toutes les lignes de la table de droite, même si aucune correspondance n’existe dans la table de gauche ?",
    "correct": "RIGHT JOIN",
    "incorrect": [
      "INNER JOIN",
      "LEFT JOIN",
      "FULL JOIN"
    ]
  },
  {
    "question": "Quelle jointure retourne toutes les lignes quand il y a une correspondance dans au moins une des deux tables ?",
    "correct": "FULL JOIN",
    "incorrect": [
      "INNER JOIN",
      "LEFT JOIN",
      "CROSS JOIN"
    ]
  },
  {
    "question": "Quel type de jointure associe chaque ligne d’une table avec toutes les lignes d’une autre table ?",
    "correct": "CROSS JOIN",
    "incorrect": [
      "INNER JOIN",
      "RIGHT JOIN",
      "FULL JOIN"
    ]
  },
  {
    "question": "Laquelle de ces jointures permet de joindre une table avec elle-même ?",
    "correct": "SELF JOIN",
    "incorrect": [
      "NATURAL JOIN",
      "FULL JOIN",
      "RIGHT JOIN"
    ]
  },
  {
    "question": "Quelle jointure s’appuie sur les colonnes ayant le même nom dans les deux tables ?",
    "correct": "NATURAL JOIN",
    "incorrect": [
      "INNER JOIN",
      "CROSS JOIN",
      "LEFT JOIN"
    ]
  },
  {
    "question": "Quelle clause SQL est utilisée pour définir la condition de jointure ?",
    "correct": "ON",
    "incorrect": [
      "WITH",
      "WHERE",
      "USING"
    ]
  },
  {
    "question": "Quelle requête permet de récupérer uniquement les lignes de la table A qui n’ont pas de correspondance dans la table B ?",
    "correct": "SELECT * FROM A LEFT JOIN B ON A.key = B.key WHERE B.key IS NULL",
    "incorrect": [
      "SELECT * FROM A INNER JOIN B ON A.key IS NULL",
      "SELECT * FROM A FULL JOIN B ON A.key = B.key WHERE B.key IS NOT NULL",
      "SELECT * FROM A RIGHT JOIN B ON A.key = B.key WHERE B.key IS NULL"
    ]
  },
  {
    "question": "Quel type de relation est généralement utilisé dans un INNER JOIN entre deux tables ?",
    "correct": "Une clé primaire et une clé étrangère",
    "incorrect": [
      "Deux clés primaires",
      "Deux colonnes de texte",
      "Deux colonnes auto-incrémentées"
    ]
  },
  {
    "question": "Quel utilisateur ne serait PAS inclus dans cette requête INNER JOIN : SELECT * FROM utilisateur INNER JOIN commande ON utilisateur.id = commande.utilisateur_id ?",
    "correct": "Un utilisateur sans commande",
    "incorrect": [
      "Un utilisateur avec plusieurs commandes",
      "Un utilisateur avec un identifiant NULL",
      "Un utilisateur avec une adresse email manquante"
    ]
  },
  {
    "question": "Dans une relation entre utilisateur.id et commande.utilisateur_id, laquelle est la clé étrangère ?",
    "correct": "commande.utilisateur_id",
    "incorrect": [
      "utilisateur.id",
      "commande.num_facture",
      "utilisateur.email"
    ]
  },
  {
    "question": "Quel type de produit résulte d’un CROSS JOIN entre une table de 5 lignes et une table de 8 lignes ?",
    "correct": "Un produit cartésien de 40 lignes",
    "incorrect": [
      "Une table de 13 lignes",
      "Une table de 5 lignes avec doublons",
      "Un tableau vide"
    ]
  },
  {
    "question": "Quelle est l’alternative syntaxique équivalente à CROSS JOIN ?",
    "correct": "FROM table1, table2",
    "incorrect": [
      "FROM table1 FULL JOIN table2",
      "FROM table1 NATURAL JOIN table2",
      "FROM table1 LEFT JOIN table2"
    ]
  },
  {
    "question": "Pourquoi faut-il faire attention en utilisant un CROSS JOIN sur de grandes tables ?",
    "correct": "Car le nombre de résultats peut être très élevé et ralentir le serveur",
    "incorrect": [
      "Car les résultats sont toujours vides",
      "Car les données sont automatiquement modifiées",
      "Car cela supprime des lignes dans la base"
    ]
  },
  {
    "question": "Quel résultat obtient-on avec : SELECT l.id AS legume_id, l.nom AS legume_nom, f.id AS fruit_id, f.nom AS fruit_nom FROM legume l CROSS JOIN fruit f; ?",
    "correct": "Toutes les combinaisons possibles entre les légumes et les fruits",
    "incorrect": [
      "Les fruits uniquement associés aux légumes ayant le même nom",
      "Une ligne par fruit uniquement",
      "Une ligne par légume uniquement"
    ]
  },
  {
    "question": "Que se passe-t-il lorsqu’il n’y a pas de correspondance dans la table de droite lors d’un LEFT JOIN ?",
    "correct": "Les colonnes de la table de droite contiennent la valeur NULL",
    "incorrect": [
      "Les lignes sont ignorées",
      "Les colonnes de la table de droite contiennent 0",
      "Une erreur est générée"
    ]
  },
  {
    "question": "Quelle clause permet de filtrer les résultats n’ayant aucune correspondance dans la table de droite ?",
    "correct": "WHERE table2.colonne IS NULL",
    "incorrect": [
      "WHERE table2.colonne = ''",
      "WHERE table2.colonne = NULL",
      "WHERE table2.colonne IS NOT NULL"
    ]
  },
  {
    "question": "Quelle est l’alternative syntaxique valide à LEFT JOIN ?",
    "correct": "LEFT OUTER JOIN",
    "incorrect": [
      "INNER JOIN OUTER",
      "OUTER LEFT JOIN",
      "JOIN OUTER LEFT"
    ]
  },
  {
    "question": "Quelle est l’alternative syntaxique correcte à RIGHT JOIN ?",
    "correct": "RIGHT OUTER JOIN",
    "incorrect": [
      "OUTER RIGHT JOIN",
      "RIGHT INNER JOIN",
      "JOIN OUTER RIGHT"
    ]
  },
  {
    "question": "Quelle requête permet d’obtenir toutes les commandes, même sans utilisateur associé ?",
    "correct": "SELECT * FROM utilisateur RIGHT JOIN commande ON utilisateur.id = commande.utilisateur_id",
    "incorrect": [
      "SELECT * FROM commande INNER JOIN utilisateur ON utilisateur.id = commande.utilisateur_id",
      "SELECT * FROM utilisateur LEFT JOIN commande ON utilisateur.id = commande.utilisateur_id",
      "SELECT * FROM commande OUTER JOIN utilisateur ON utilisateur.id = commande.utilisateur_id"
    ]
  },
  {
    "question": "Dans le résultat d’un RIGHT JOIN, que signifie une valeur NULL dans les colonnes de la table de gauche ?",
    "correct": "Il n’existe pas d’enregistrement correspondant dans la table de gauche",
    "incorrect": [
      "La table de gauche est vide",
      "La valeur est inconnue",
      "L’enregistrement est invalide"
    ]
  },
  {
    "question": "Quel est le rôle principal de la commande SQL FULL JOIN ?",
    "correct": "Retourner tous les enregistrements des deux tables, même sans correspondance",
    "incorrect": [
      "Retourner uniquement les enregistrements communs aux deux tables",
      "Retourner tous les enregistrements de la table de gauche",
      "Retourner tous les enregistrements de la table de droite"
    ]
  },
  {
    "question": "Que signifie une valeur NULL dans une colonne issue d’une des deux tables après un FULL JOIN ?",
    "correct": "Aucune correspondance n’a été trouvée dans l’autre table",
    "incorrect": [
      "La donnée est invalide",
      "La valeur a été supprimée",
      "L’enregistrement est dupliqué"
    ]
  },
  {
    "question": "Quelle est l'alternative syntaxique correcte à FULL JOIN ?",
    "correct": "FULL OUTER JOIN",
    "incorrect": [
      "OUTER FULL JOIN",
      "JOIN OUTER FULL",
      "FULL INNER JOIN"
    ]
  },
  {
    "question": "Quel type de résultat le FULL JOIN retourne-t-il ?",
    "correct": "Les enregistrements appariés et non appariés des deux tables",
    "incorrect": [
      "Uniquement les résultats appariés",
      "Uniquement les résultats non appariés",
      "Seulement les résultats de la table la plus grande"
    ]
  },
  {
    "question": "Quel est l'avantage d'un FULL JOIN par rapport à un INNER JOIN ?",
    "correct": "Il affiche aussi les enregistrements sans correspondance",
    "incorrect": [
      "Il est plus rapide à exécuter",
      "Il élimine les doublons automatiquement",
      "Il trie les résultats par défaut"
    ]
  },
  {
    "question": "Pourquoi l'utilisateur avec l'identifiant 4 s'affiche avec des valeurs NULL pour les colonnes de la table commande ?",
    "correct": "Parce qu’il n’a effectué aucune commande",
    "incorrect": [
      "Parce qu’il a été supprimé de la base",
      "Parce que la commande est invalide",
      "Parce qu’il est inactif"
    ]
  },
  {
    "question": "Pourquoi la facture A00107 est-elle affichée avec des valeurs NULL pour les colonnes utilisateur ?",
    "correct": "Parce qu’aucun utilisateur avec l’identifiant 5 n’existe",
    "incorrect": [
      "Parce que l’utilisateur a été désactivé",
      "Parce que la commande est incomplète",
      "Parce que les colonnes utilisateur sont facultatives"
    ]
  },
  {
    "question": "Quelle condition de jointure est utilisée dans le FULL JOIN présenté dans l’exemple ?",
    "correct": "utilisateur.id = commande.utilisateur_id",
    "incorrect": [
      "commande.id = utilisateur.utilisateur_id",
      "utilisateur.nom = commande.nom",
      "utilisateur.email = commande.email"
    ]
  },
  {
    "question": "Quel est le comportement du FULL JOIN si une ligne existe uniquement dans la table de gauche ?",
    "correct": "Elle est incluse avec des valeurs NULL pour les colonnes de la table de droite",
    "incorrect": [
      "Elle est exclue du résultat",
      "Elle est dupliquée dans la table de droite",
      "Elle provoque une erreur"
    ]
  },
  {
    "question": "Quel est le bon usage du FULL JOIN dans le cas de l'exemple présenté ?",
    "correct": "Lister toutes les commandes et tous les utilisateurs, même sans correspondance entre eux",
    "incorrect": [
      "Afficher uniquement les commandes ayant un utilisateur actif",
      "Afficher uniquement les utilisateurs ayant passé une commande",
      "Afficher uniquement les utilisateurs et commandes liés"
    ]
  },
  {
    "question": "Qu'est-ce qu'un SELF JOIN en SQL ?",
    "correct": "Une jointure d’une table avec elle-même",
    "incorrect": [
      "Une jointure de deux bases de données",
      "Une jointure entre deux champs d'une même ligne",
      "Une jointure avec une table temporaire"
    ]
  },
  {
    "question": "Quel mot-clé est utilisé pour différencier les deux instances de la même table dans un SELF JOIN ?",
    "correct": "AS",
    "incorrect": [
      "JOIN",
      "FROM",
      "WITH"
    ]
  },
  {
    "question": "Dans l’exemple donné, à quoi correspond la colonne manager_id ?",
    "correct": "À l’identifiant du supérieur hiérarchique d’un employé",
    "incorrect": [
      "Au nombre de subordonnés",
      "À l'adresse email du manager",
      "À un identifiant externe"
    ]
  },
  {
    "question": "Quel type de jointure est utilisé dans l’exemple du SELF JOIN ?",
    "correct": "LEFT OUTER JOIN",
    "incorrect": [
      "RIGHT JOIN",
      "INNER JOIN",
      "FULL JOIN"
    ]
  },
  {
    "question": "Pourquoi utilise-t-on des alias (u1, u2) dans un SELF JOIN ?",
    "correct": "Pour distinguer les deux instances de la même table",
    "incorrect": [
      "Pour renommer les colonnes",
      "Pour appliquer une fonction d’agrégation",
      "Pour simplifier la syntaxe des fonctions"
    ]
  },
  {
    "question": "Que retourne la requête SELF JOIN dans l'exemple ?",
    "correct": "Une liste d’employés avec leur supérieur direct",
    "incorrect": [
      "Une liste des employés sans supérieur",
      "Une liste des supérieurs avec leurs départements",
      "Une liste d’employés classés par ancienneté"
    ]
  },
  {
    "question": "Quelles valeurs apparaissent dans les colonnes du supérieur si un employé n’a pas de manager ?",
    "correct": "NULL",
    "incorrect": [
      "0",
      "Erreur SQL",
      "La valeur du champ id"
    ]
  },
  {
    "question": "Quel est l’intérêt principal d’un SELF JOIN dans une table hiérarchique ?",
    "correct": "Associer chaque élément avec un autre élément de la même table",
    "incorrect": [
      "Supprimer les doublons dans la table",
      "Créer une nouvelle table à partir de la table existante",
      "Importer des données depuis une autre base"
    ]
  },
  {
    "question": "Quel champ est utilisé pour relier un employé à son supérieur dans l'exemple ?",
    "correct": "u_manager_id",
    "incorrect": [
      "u_email",
      "u_prenom",
      "u_nom"
    ]
  },
  {
    "question": "Quelle situation rend l’utilisation d’un SELF JOIN particulièrement utile ?",
    "correct": "Les structures hiérarchiques comme les employés et leurs managers",
    "incorrect": [
      "Les jointures entre des données de deux bases différentes",
      "Les imports de fichiers CSV",
      "Les calculs de moyennes sur plusieurs colonnes"
    ]
  },
  {
    "question": "Quel est le rôle de la commande SQL NATURAL JOIN ?",
    "correct": "Faire une jointure automatique sur les colonnes de même nom et de même type",
    "incorrect": [
      "Faire une jointure entre deux bases de données différentes",
      "Associer toutes les lignes d’une table avec toutes celles d’une autre",
      "Créer des noms de colonnes dynamiquement"
    ]
  },
  {
    "question": "Quelle condition est nécessaire pour qu’un NATURAL JOIN fonctionne ?",
    "correct": "Avoir des colonnes de même nom et de même type dans les deux tables",
    "incorrect": [
      "Avoir des clés primaires dans les deux tables",
      "Que les noms de table soient identiques",
      "Que les données soient triées"
    ]
  },
  {
    "question": "Quel est l’avantage principal d’un NATURAL JOIN ?",
    "correct": "Il n’est pas nécessaire de spécifier la condition de jointure avec ON",
    "incorrect": [
      "Il peut créer automatiquement une nouvelle table",
      "Il peut fusionner les types de données",
      "Il trie automatiquement les résultats"
    ]
  },
  {
    "question": "Quelle syntaxe correspond à un NATURAL JOIN ?",
    "correct": "SELECT * FROM table1 NATURAL JOIN table2",
    "incorrect": [
      "SELECT * FROM table1 INNER JOIN table2 ON condition",
      "SELECT * FROM table1 LEFT JOIN table2 USING (colonne)",
      "SELECT * FROM table1 CROSS JOIN table2"
    ]
  },
  {
    "question": "Dans l’exemple fourni, quelle colonne est utilisée pour faire la jointure naturelle ?",
    "correct": "pays_id",
    "incorrect": [
      "user_id",
      "pays_nom",
      "user_ville"
    ]
  },
  {
    "question": "Que se passe-t-il si une valeur de pays_id n'existe pas dans la table pays ?",
    "correct": "La valeur du champ pays_nom est NULL",
    "incorrect": [
      "Une erreur est renvoyée",
      "La ligne est ignorée",
      "Une valeur par défaut est insérée"
    ]
  },
  {
    "question": "Pourquoi la ligne concernant 'Sophie' a-t-elle des valeurs NULL dans les colonnes de la table pays ?",
    "correct": "Parce que pays_id vaut NULL et qu’aucune correspondance ne peut être faite",
    "incorrect": [
      "Parce qu'elle n’est pas active",
      "Parce que le pays_id est incorrect",
      "Parce qu’elle a plusieurs enregistrements"
    ]
  },
  {
    "question": "Quel est un inconvénient du NATURAL JOIN ?",
    "correct": "Il impose d’avoir des noms de colonnes identiques dans les deux tables",
    "incorrect": [
      "Il ne permet pas d’utiliser des alias",
      "Il fonctionne uniquement avec des clés primaires",
      "Il nécessite plus de mémoire que les autres jointures"
    ]
  },
  {
    "question": "Que retourne un NATURAL JOIN si aucune colonne n’a le même nom dans les deux tables ?",
    "correct": "Une erreur ou un produit cartésien selon le SGBD",
    "incorrect": [
      "Une table vide",
      "Une fusion automatique des colonnes",
      "Une alerte mais les données sont retournées"
    ]
  },
  {
    "question": "Pourquoi ne peut-on pas préfixer les noms de colonnes avec des identifiants personnalisés dans un NATURAL JOIN ?",
    "correct": "Parce que cela empêche d’avoir des noms strictement identiques dans les deux tables",
    "incorrect": [
      "Parce que cela crée une erreur de syntaxe SQL",
      "Parce que NATURAL JOIN ne supporte pas les alias",
      "Parce que les noms longs sont interdits"
    ]
  },
  {
    "question": "Qu’est-ce qu’une sous-requête en SQL ?",
    "correct": "Une requête imbriquée à l’intérieur d’une autre requête",
    "incorrect": [
      "Une requête exécutée en parallèle de la requête principale",
      "Une requête exécutée uniquement sur des vues",
      "Une requête de mise à jour automatique"
    ]
  },
  {
    "question": "Où sont généralement utilisées les sous-requêtes ?",
    "correct": "Dans les clauses WHERE ou HAVING",
    "incorrect": [
      "Dans les noms de colonnes",
      "Dans la clause FROM uniquement",
      "Dans les contraintes PRIMARY KEY"
    ]
  },
  {
    "question": "Quelle commande SQL est souvent utilisée avec une sous-requête qui retourne une colonne ?",
    "correct": "IN",
    "incorrect": [
      "GROUP BY",
      "LIMIT",
      "UNION"
    ]
  },
  {
    "question": "Que permet la requête suivante ?\nSELECT * FROM question WHERE q_id = (SELECT r_fk_question_id FROM reponse ORDER BY r_date_ajout DESC LIMIT 1)",
    "correct": "Afficher la question liée à la dernière réponse postée",
    "incorrect": [
      "Afficher la réponse la plus ancienne",
      "Afficher toutes les réponses d’une question",
      "Afficher toutes les questions sans réponse"
    ]
  },
  {
    "question": "Quel opérateur peut être utilisé dans une sous-requête pour tester l’égalité ?",
    "correct": "=",
    "incorrect": [
      "SELECT",
      "FROM",
      "HAVING"
    ]
  },
  {
    "question": "Quelle erreur peut survenir si une sous-requête retourne plusieurs lignes mais est utilisée avec un opérateur = ?",
    "correct": "Erreur car l’opérateur = attend une seule valeur",
    "incorrect": [
      "Erreur de syntaxe dans la table principale",
      "La sous-requête sera ignorée",
      "Toutes les lignes seront sélectionnées sans erreur"
    ]
  },
  {
    "question": "Quel est l’intérêt d’une sous-requête dans une clause IN ?",
    "correct": "Filtrer les résultats selon une liste dynamique de valeurs",
    "incorrect": [
      "Effectuer un tri automatique",
      "Limiter le nombre de lignes retournées",
      "Transformer les colonnes en lignes"
    ]
  },
  {
    "question": "Pourquoi utiliser une sous-requête dans une clause WHERE ?",
    "correct": "Pour utiliser le résultat d’une autre requête comme critère de filtrage",
    "incorrect": [
      "Pour afficher plusieurs tables sans jointure",
      "Pour remplacer la clause SELECT",
      "Pour modifier dynamiquement le schéma de la table"
    ]
  },
  {
    "question": "Quelle commande peut encapsuler une sous-requête dans une clause de comparaison ?",
    "correct": "BETWEEN",
    "incorrect": [
      "JOIN",
      "AS",
      "GROUP"
    ]
  },
  {
    "question": "Quelle est la principale différence entre une sous-requête et une jointure ?",
    "correct": "La sous-requête est imbriquée dans une autre requête, la jointure combine directement plusieurs tables",
    "incorrect": [
      "La jointure ne fonctionne qu’avec les vues",
      "La sous-requête ne peut pas utiliser la clause WHERE",
      "La jointure ne peut jamais être utilisée avec SELECT"
    ]
  },
  {
    "question": "Quel est le rôle de la commande SQL EXISTS ?",
    "correct": "Tester si une sous-requête retourne au moins un résultat",
    "incorrect": [
      "Retourner les lignes en double dans une table",
      "Supprimer les lignes vides d'une table",
      "Comparer les valeurs d'une colonne avec une liste"
    ]
  },
  {
    "question": "Dans quelle clause est généralement utilisée la commande EXISTS ?",
    "correct": "WHERE",
    "incorrect": [
      "GROUP BY",
      "ORDER BY",
      "SELECT"
    ]
  },
  {
    "question": "Quelle est la principale différence entre EXISTS et IN ?",
    "correct": "EXISTS vérifie la présence de résultats, IN compare des valeurs précises",
    "incorrect": [
      "EXISTS ne peut pas utiliser de sous-requête",
      "IN est plus rapide que EXISTS dans tous les cas",
      "EXISTS permet uniquement des jointures"
    ]
  },
  {
    "question": "Quel sera le comportement d’une requête avec EXISTS si la sous-requête ne retourne aucune ligne ?",
    "correct": "La requête principale ne retournera aucun résultat",
    "incorrect": [
      "La requête principale retournera toutes les lignes",
      "Une erreur sera générée",
      "Toutes les colonnes de la requête principale auront la valeur NULL"
    ]
  },
  {
    "question": "Quel est l’intérêt de la commande EXISTS par rapport à une jointure ?",
    "correct": "Elle ne modifie pas la structure du résultat de la requête principale",
    "incorrect": [
      "Elle permet d’ajouter des colonnes dynamiques à la table",
      "Elle fonctionne uniquement avec les vues",
      "Elle fusionne les lignes de plusieurs tables"
    ]
  },
  {
    "question": "Quel est le résultat de cette requête ?\nSELECT * FROM commande WHERE EXISTS (SELECT * FROM produit WHERE c_produit_id = p_id)",
    "correct": "Les commandes pour lesquelles un produit existe dans la table produit",
    "incorrect": [
      "Toutes les commandes sans produit",
      "Toutes les lignes de la table produit",
      "Les produits qui ne sont pas liés à une commande"
    ]
  },
  {
    "question": "Que retourne EXISTS si la sous-requête contient au moins une ligne ?",
    "correct": "TRUE",
    "incorrect": [
      "FALSE",
      "NULL",
      "Une erreur de syntaxe"
    ]
  },
  {
    "question": "Dans l'exemple fourni, pourquoi la commande avec c_id = 3 n'apparaît-elle pas dans les résultats ?",
    "correct": "Parce que c_produit_id = 8 n'existe pas dans la table produit",
    "incorrect": [
      "Parce que la quantité est égale à 1",
      "Parce que l’ID de la commande est impair",
      "Parce que le prix du produit est inconnu"
    ]
  },
  {
    "question": "Quelle est une bonne raison d'utiliser EXISTS au lieu de JOIN ?",
    "correct": "On veut vérifier une condition sans dupliquer les lignes ni retourner les colonnes supplémentaires",
    "incorrect": [
      "On veut automatiquement insérer des valeurs",
      "On veut renommer une table",
      "On veut trier les résultats selon plusieurs colonnes"
    ]
  },
  {
    "question": "EXISTS retourne TRUE si :",
    "correct": "La sous-requête retourne au moins une ligne",
    "incorrect": [
      "Toutes les lignes de la sous-requête sont NULL",
      "La requête principale contient une clause GROUP BY",
      "La sous-requête contient une clause LIMIT"
    ]
  },
  {
    "question": "Quel est le rôle principal de la commande SQL ALL ?",
    "correct": "Comparer une valeur à l’ensemble des résultats d’une sous-requête",
    "incorrect": [
      "Associer deux tables par une clé étrangère",
      "Retourner toutes les lignes sans condition",
      "Ajouter toutes les valeurs d’une colonne"
    ]
  },
  {
    "question": "Dans quelle clause la commande ALL est-elle utilisée ?",
    "correct": "WHERE",
    "incorrect": [
      "GROUP BY",
      "SELECT",
      "ORDER BY"
    ]
  },
  {
    "question": "La condition suivante est-elle vraie ?\n10 > ALL (SELECT valeur FROM table2) sachant que table2 retourne {-5, 0, 5}",
    "correct": "Oui, car toutes les valeurs de table2 sont inférieures à 10",
    "incorrect": [
      "Non, car 0 est égal à 10",
      "Non, car une des valeurs est négative",
      "Oui, car la sous-requête retourne plus d'une valeur"
    ]
  },
  {
    "question": "Quels opérateurs peuvent être utilisés avec ALL ?",
    "correct": "=, <, >, <>, !=, <=, >=",
    "incorrect": [
      "ONLY, EXCEPT, ADD",
      "MATCH, SPLIT, TRUNCATE",
      "LIKE, BETWEEN, REGEXP"
    ]
  },
  {
    "question": "Quelle sera la valeur de la condition si la sous-requête utilisée avec ALL est vide ?",
    "correct": "UNKNOWN",
    "incorrect": [
      "TRUE",
      "FALSE",
      "0"
    ]
  },
  {
    "question": "Quel est le résultat de cette requête ?\nSELECT * FROM produits WHERE prix > ALL (SELECT prix FROM soldes)\nSi 'soldes' contient 15, 20 et 30 et qu’un produit a un prix de 35.",
    "correct": "Le produit sera affiché",
    "incorrect": [
      "Le produit sera ignoré",
      "Une erreur sera générée",
      "La condition ne peut pas être évaluée"
    ]
  },
  {
    "question": "Dans quel cas la condition colonne1 > ALL (SELECT colonne1 FROM table2) sera-t-elle FALSE ?",
    "correct": "Si au moins une valeur de table2 est supérieure ou égale à colonne1",
    "incorrect": [
      "Si toutes les valeurs sont NULL",
      "Si table2 est vide",
      "Si colonne1 est une chaîne de caractères"
    ]
  },
  {
    "question": "La commande ALL est particulièrement utile quand :",
    "correct": "On veut vérifier qu’une condition est vraie pour tous les éléments retournés",
    "incorrect": [
      "On veut calculer la moyenne d’une colonne",
      "On veut créer une nouvelle table",
      "On veut supprimer les doublons d’une table"
    ]
  },
  {
    "question": "Que renvoie une comparaison avec ALL si la sous-requête retourne au moins un NULL ?",
    "correct": "La condition est FALSE si une autre valeur rend la comparaison fausse",
    "incorrect": [
      "La condition est toujours TRUE",
      "La condition est ignorée",
      "La comparaison renvoie une erreur"
    ]
  },
  {
    "question": "Que permet de faire cette requête ?\nSELECT * FROM clients WHERE age >= ALL (SELECT age FROM clients_zone)",
    "correct": "Sélectionner les clients ayant un âge supérieur ou égal à tous ceux de clients_zone",
    "incorrect": [
      "Sélectionner tous les clients de la zone",
      "Sélectionner uniquement les clients les plus jeunes",
      "Ignorer tous les clients ayant un âge inconnu"
    ]
  },
  {
    "question": "Quel est le rôle principal de la commande SQL ANY (ou SOME) ?",
    "correct": "Comparer une valeur avec au moins un des résultats d’une sous-requête",
    "incorrect": [
      "Comparer toutes les valeurs d’une table entre elles",
      "Récupérer toutes les lignes d’une table",
      "Vérifier qu’une valeur est identique dans toutes les lignes"
    ]
  },
  {
    "question": "Quelle est la différence entre SQL ANY et SQL SOME ?",
    "correct": "Il n’y a aucune différence, ce sont des synonymes",
    "incorrect": [
      "SOME est utilisé avec des types numériques uniquement",
      "ANY est plus rapide que SOME",
      "SOME est une commande obsolète"
    ]
  },
  {
    "question": "Quelle est la signification de cette requête :\nSELECT * FROM produit WHERE prix < ANY (SELECT prix FROM promotions)",
    "correct": "Elle retourne les produits dont le prix est inférieur à au moins un prix de la table promotions",
    "incorrect": [
      "Elle retourne les produits les moins chers de la table promotions",
      "Elle retourne tous les produits ayant le même prix que les promotions",
      "Elle retourne uniquement les produits de la table promotions"
    ]
  },
  {
    "question": "Quels opérateurs peuvent être utilisés avec ANY ?",
    "correct": "=, <, >, <>, !=, <=, >=",
    "incorrect": [
      "LIKE, BETWEEN, REGEXP",
      "UNION, INTERSECT, MINUS",
      "ADD, MULTIPLY, DIVIDE"
    ]
  },
  {
    "question": "Dans quel cas une condition utilisant ANY retourne FALSE ?",
    "correct": "Si aucune des valeurs de la sous-requête ne satisfait la condition",
    "incorrect": [
      "Si la sous-requête retourne un NULL",
      "Si la table est vide",
      "Si toutes les valeurs sont identiques"
    ]
  },
  {
    "question": "Quelle est la valeur de la condition si la sous-requête utilisée avec ANY est vide ?",
    "correct": "UNKNOWN",
    "incorrect": [
      "TRUE",
      "FALSE",
      "NULL"
    ]
  },
  {
    "question": "Quel est l’équivalent logique de cette expression : colonne IN (SELECT valeur FROM t2) ?",
    "correct": "colonne = ANY (SELECT valeur FROM t2)",
    "incorrect": [
      "colonne > ALL (SELECT valeur FROM t2)",
      "colonne != SOME (SELECT valeur FROM t2)",
      "colonne < ANY (SELECT valeur FROM t2)"
    ]
  },
  {
    "question": "Supposons que table2 contient {21, 14, 7}, que retourne cette requête :\nSELECT * FROM table1 WHERE 10 > ANY (SELECT valeur FROM table2)",
    "correct": "TRUE, car 7 est inférieur à 10",
    "incorrect": [
      "FALSE, car aucune valeur ne correspond",
      "TRUE, car 21 est supérieur à 10",
      "UNKNOWN, car la sous-requête retourne plusieurs valeurs"
    ]
  },
  {
    "question": "Que se passe-t-il si la sous-requête utilisée avec ANY contient uniquement des valeurs NULL ?",
    "correct": "La condition retourne UNKNOWN",
    "incorrect": [
      "La condition retourne TRUE",
      "La condition retourne FALSE",
      "Une erreur est générée"
    ]
  },
  {
    "question": "La commande ANY est particulièrement utile pour :",
    "correct": "Vérifier si une condition est vraie pour au moins une valeur d’un sous-ensemble",
    "incorrect": [
      "Appliquer un filtre global sur toutes les lignes",
      "Fusionner plusieurs tables entre elles",
      "Obtenir des statistiques sur une table"
    ]
  },
  {
    "question": "Quel est le principal avantage d’un index en SQL ?",
    "correct": "Accélérer l’accès aux données lors des requêtes",
    "incorrect": [
      "Réduire la taille de la base de données",
      "Empêcher les doublons dans une table",
      "Optimiser les insertions de données"
    ]
  },
  {
    "question": "Quel est l’inconvénient principal de l’utilisation d’index ?",
    "correct": "Les insertions deviennent plus lentes car les index doivent être mis à jour",
    "incorrect": [
      "Ils empêchent l’utilisation des jointures",
      "Ils suppriment automatiquement les doublons",
      "Ils bloquent l’utilisation des sous-requêtes"
    ]
  },
  {
    "question": "Quelle analogie est utilisée pour expliquer le fonctionnement d’un index SQL ?",
    "correct": "Un index dans un livre qui indique les pages contenant un mot-clé",
    "incorrect": [
      "Une table des matières listant tous les chapitres",
      "Un glossaire donnant la définition des termes techniques",
      "Un sommaire décrivant le contenu d’un document"
    ]
  },
  {
    "question": "Dans quels cas l’index SQL est-il particulièrement utile ?",
    "correct": "Lorsqu’une table contient un grand nombre d’enregistrements",
    "incorrect": [
      "Lorsque la base contient uniquement des tables temporaires",
      "Lorsque toutes les colonnes sont en type TEXT",
      "Lorsque la base de données est vide"
    ]
  },
  {
    "question": "Quel est l’impact d’un index sur les requêtes de type SELECT avec WHERE ?",
    "correct": "Il permet d’accélérer considérablement la recherche",
    "incorrect": [
      "Il empêche l’utilisation de la clause WHERE",
      "Il oblige à écrire la requête en majuscules",
      "Il ralentit la lecture des données"
    ]
  },
  {
    "question": "Quelles clauses bénéficient généralement de la présence d’un index ?",
    "correct": "WHERE, GROUP BY, ORDER BY",
    "incorrect": [
      "INSERT, DELETE, DROP",
      "JOIN, HAVING, TRUNCATE",
      "SELECT, RENAME, COMMENT"
    ]
  },
  {
    "question": "Pourquoi un index peut-il ralentir les opérations d’insertion ?",
    "correct": "Car chaque insertion met à jour les index associés",
    "incorrect": [
      "Car les données doivent être vérifiées manuellement",
      "Car les valeurs sont converties en texte",
      "Car la commande INSERT est bloquée en présence d’un index"
    ]
  },
  {
    "question": "L’index en SQL est-il indispensable au fonctionnement d’une requête ?",
    "correct": "Non, mais il améliore les performances de lecture",
    "incorrect": [
      "Oui, sinon la requête ne peut pas être exécutée",
      "Oui, pour toute base relationnelle",
      "Non, car il bloque toutes les jointures"
    ]
  },
  {
    "question": "Que consomme un index dans une base de données ?",
    "correct": "De l’espace disque supplémentaire",
    "incorrect": [
      "Des droits d’accès spécifiques",
      "Des threads de calcul dédiés",
      "Un identifiant unique par table"
    ]
  },
  {
    "question": "Quand faut-il envisager la création d’un index ?",
    "correct": "Lorsque certaines requêtes sont lentes à cause d’un grand volume de données",
    "incorrect": [
      "Dès que la base de données contient une seule table",
      "Uniquement si toutes les colonnes sont de type VARCHAR",
      "Quand les index sont désactivés automatiquement"
    ]
  },
  {
    "question": "Quel est le rôle principal de l'instruction SQL EXPLAIN ?",
    "correct": "Afficher le plan d'exécution d'une requête",
    "incorrect": [
      "Corriger automatiquement les erreurs de requête",
      "Afficher les résultats de la requête",
      "Créer un index pour optimiser la requête"
    ]
  },
  {
    "question": "Quelle commande faut-il utiliser dans MySQL pour analyser une requête SQL ?",
    "correct": "EXPLAIN SELECT ...",
    "incorrect": [
      "ANALYZE SELECT ...",
      "DESCRIBE SELECT ...",
      "SHOW PLAN SELECT ..."
    ]
  },
  {
    "question": "Quel est l’impact de la commande EXPLAIN sur les résultats d’un SELECT ?",
    "correct": "Elle n'affiche pas les données mais les détails d'exécution",
    "incorrect": [
      "Elle affiche uniquement les lignes avec erreurs",
      "Elle affiche les lignes du SELECT de façon optimisée",
      "Elle double les lignes retournées"
    ]
  },
  {
    "question": "Quel champ de résultat d’un EXPLAIN indique le type de jointure utilisé ?",
    "correct": "type",
    "incorrect": [
      "key_len",
      "ref",
      "select_type"
    ]
  },
  {
    "question": "Dans une sortie EXPLAIN, que signifie la valeur 'ALL' dans la colonne 'type' ?",
    "correct": "Un scan complet de la table est effectué",
    "incorrect": [
      "Tous les index sont utilisés",
      "Tous les résultats sont ignorés",
      "Tous les types de données sont acceptés"
    ]
  },
  {
    "question": "Quelle colonne d’un EXPLAIN indique l’index réellement utilisé par MySQL ?",
    "correct": "key",
    "incorrect": [
      "possible_keys",
      "ref",
      "rows"
    ]
  },
  {
    "question": "Que signifie la mention 'Using filesort' dans la colonne 'Extra' d’un EXPLAIN ?",
    "correct": "MySQL trie les lignes en mémoire ou sur disque",
    "incorrect": [
      "MySQL ignore les index",
      "Les fichiers de la table sont supprimés",
      "L’ordre des résultats est aléatoire"
    ]
  },
  {
    "question": "Quel effet a la commande ALTER TABLE ... ADD INDEX ... ?",
    "correct": "Elle ajoute un index qui peut optimiser certaines requêtes",
    "incorrect": [
      "Elle supprime les doublons dans la table",
      "Elle empêche les requêtes UPDATE",
      "Elle fusionne deux colonnes"
    ]
  },
  {
    "question": "Que montre la colonne 'rows' dans le résultat de EXPLAIN ?",
    "correct": "Une estimation du nombre de lignes examinées",
    "incorrect": [
      "Le nombre total de résultats retournés",
      "Le nombre de colonnes utilisées",
      "Le nombre d’index créés"
    ]
  },
  {
    "question": "Quelle instruction SQL est équivalente à EXPLAIN sous Oracle ?",
    "correct": "EXPLAIN PLAN",
    "incorrect": [
      "DESCRIBE PLAN",
      "SHOW EXECUTION",
      "ANALYZE QUERY"
    ]
  },
  {
    "question": "Quel est le but principal de la commande SQL OPTIMIZE ?",
    "correct": "Réorganiser le stockage et reconstruire les index",
    "incorrect": [
      "Créer une sauvegarde de la table",
      "Exporter les données dans un fichier",
      "Réinitialiser les valeurs AUTO_INCREMENT"
    ]
  },
  {
    "question": "Quel est le bon mot-clé SQL pour optimiser une table dans MySQL ?",
    "correct": "OPTIMIZE TABLE",
    "incorrect": [
      "ANALYZE TABLE",
      "CLEANUP TABLE",
      "REPAIR TABLE"
    ]
  },
  {
    "question": "Sur quel type de base de données la commande OPTIMIZE est-elle disponible ?",
    "correct": "MySQL et MariaDB",
    "incorrect": [
      "PostgreSQL et SQLite",
      "Oracle et Firebird",
      "SQL Server et IBM DB2"
    ]
  },
  {
    "question": "Que se passe-t-il après une suppression massive de données si OPTIMIZE n'est pas exécutée ?",
    "correct": "L’espace utilisé reste le même jusqu’à optimisation",
    "incorrect": [
      "La table est automatiquement compressée",
      "Les index sont supprimés",
      "Les lignes restantes sont dupliquées"
    ]
  },
  {
    "question": "Quel effet a OPTIMIZE TABLE sur les index ?",
    "correct": "Les index sont reconstruits",
    "incorrect": [
      "Les index sont supprimés",
      "Les index sont renommés",
      "Les index sont convertis en clé étrangère"
    ]
  },
  {
    "question": "Quand est-il pertinent d’utiliser OPTIMIZE TABLE ?",
    "correct": "Après une suppression importante de données",
    "incorrect": [
      "Avant une commande INSERT",
      "Après une erreur de syntaxe",
      "Pour afficher les données d'une table"
    ]
  },
  {
    "question": "Quelle commande est correcte pour optimiser une table nommée `utilisateur` ?",
    "correct": "OPTIMIZE TABLE utilisateur;",
    "incorrect": [
      "REINDEX utilisateur;",
      "ANALYZE utilisateur;",
      "OPTIMIZE utilisateur;"
    ]
  },
  {
    "question": "Quel est l’un des bénéfices concrets après exécution d’un OPTIMIZE TABLE ?",
    "correct": "Réduction de la taille physique de la table",
    "incorrect": [
      "Suppression des données en double",
      "Ajout automatique d’index manquants",
      "Conversion du format de la table"
    ]
  },
  {
    "question": "Que devient la taille de la table après un OPTIMIZE TABLE dans l'exemple fourni ?",
    "correct": "Elle passe de 10.7 Mo à 5.4 Mo",
    "incorrect": [
      "Elle augmente à 12 Mo",
      "Elle reste à 10.7 Mo",
      "Elle devient nulle"
    ]
  },
  {
    "question": "Pourquoi la table semble-t-elle encore faire 10.7 Mo après une suppression ?",
    "correct": "L’espace n’est pas immédiatement libéré sans OPTIMIZE",
    "incorrect": [
      "Les lignes sont déplacées en cache",
      "La table est recréée en arrière-plan",
      "Les données sont cryptées"
    ]
  },
  {
    "question": "Quel est le rôle principal des commentaires en SQL ?",
    "correct": "Faciliter la lecture et la compréhension des requêtes",
    "incorrect": [
      "Exécuter plusieurs requêtes à la fois",
      "Ignorer les erreurs de syntaxe",
      "Créer des fonctions dans les tables"
    ]
  },
  {
    "question": "Quel symbole utilise-t-on pour faire un commentaire en SQL jusqu’à la fin de la ligne ?",
    "correct": "--",
    "incorrect": [
      "//",
      "/*",
      "<!--"
    ]
  },
  {
    "question": "Le symbole # est reconnu comme un commentaire jusqu’à la fin de la ligne par :",
    "correct": "MySQL uniquement",
    "incorrect": [
      "PostgreSQL uniquement",
      "Tous les SGBD",
      "Oracle et SQL Server"
    ]
  },
  {
    "question": "Quelle syntaxe permet de faire un commentaire multi-ligne en SQL ?",
    "correct": "/* commentaire */",
    "incorrect": [
      "-- commentaire --",
      "## commentaire ##",
      "// commentaire //"
    ]
  },
  {
    "question": "Quelle est la particularité des commentaires multi-ligne ?",
    "correct": "Ils peuvent être insérés au milieu d’une requête",
    "incorrect": [
      "Ils suppriment les lignes de la base de données",
      "Ils sont interprétés comme du code",
      "Ils ne sont compatibles qu’avec MySQL"
    ]
  },
  {
    "question": "Quel risque existe-t-il avec l’utilisation de commentaires sur une seule ligne ?",
    "correct": "Un commentaire peut masquer une partie de la requête si tout est sur une seule ligne",
    "incorrect": [
      "Ils suppriment les index automatiquement",
      "Ils déclenchent une erreur de compilation",
      "Ils transforment le SELECT en DELETE"
    ]
  },
  {
    "question": "Quelle syntaxe est correcte pour commenter une ligne dans MySQL ?",
    "correct": "# Ceci est un commentaire",
    "incorrect": [
      "<!-- Ceci est un commentaire -->",
      "// Ceci est un commentaire",
      "%% Ceci est un commentaire"
    ]
  },
  {
    "question": "Quels SGBD acceptent les commentaires multi-ligne ?",
    "correct": "MySQL, PostgreSQL, Oracle, SQL Server et SQLite",
    "incorrect": [
      "Uniquement Oracle et PostgreSQL",
      "Uniquement MySQL et SQLite",
      "Tous sauf SQL Server"
    ]
  },
  {
    "question": "Quelle syntaxe est invalide pour un commentaire en SQL ?",
    "correct": "// commentaire",
    "incorrect": [
      "-- commentaire",
      "# commentaire",
      "/* commentaire */"
    ]
  },
  {
    "question": "Quel est le principal avantage des commentaires dans les requêtes SQL complexes ?",
    "correct": "Expliquer les différentes parties de la requête",
    "incorrect": [
      "Augmenter la vitesse d’exécution",
      "Réduire la taille de la base",
      "Transformer les résultats en JSON"
    ]
  },
  {
    "question": "Quelle fonction d’agrégation permet de calculer la moyenne d’une colonne ?",
    "correct": "AVG()",
    "incorrect": [
      "SUM()",
      "MEAN()",
      "COUNT()"
    ]
  },
  {
    "question": "Quelle fonction SQL retourne le nombre total de lignes d’une table ?",
    "correct": "COUNT(*)",
    "incorrect": [
      "SUM(*)",
      "TOTAL(*)",
      "AVG(*)"
    ]
  },
  {
    "question": "Quelle fonction permet d’obtenir la plus grande valeur dans une colonne ?",
    "correct": "MAX()",
    "incorrect": [
      "TOP()",
      "HIGH()",
      "UPPER()"
    ]
  },
  {
    "question": "Quelle fonction permet de calculer la somme des valeurs d’une colonne ?",
    "correct": "SUM()",
    "incorrect": [
      "TOTAL()",
      "ADD()",
      "PLUS()"
    ]
  },
  {
    "question": "Quel mot-clé SQL est couramment utilisé avec les fonctions d’agrégation pour regrouper les résultats ?",
    "correct": "GROUP BY",
    "incorrect": [
      "ORDER BY",
      "MERGE BY",
      "PARTITION BY"
    ]
  },
  {
    "question": "Que retourne la fonction COUNT(colonne) ?",
    "correct": "Le nombre de valeurs non NULL dans la colonne",
    "incorrect": [
      "Le total des valeurs numériques de la colonne",
      "La taille moyenne des enregistrements",
      "Le nombre de lignes de la table, y compris les NULL"
    ]
  },
  {
    "question": "Quelle fonction permet d’obtenir la plus petite valeur dans une colonne ?",
    "correct": "MIN()",
    "incorrect": [
      "LOW()",
      "LEAST()",
      "BOTTOM()"
    ]
  },
  {
    "question": "Que permet de faire la requête suivante : SELECT client, SUM(tarif) FROM achat GROUP BY client ?",
    "correct": "Afficher le total des achats par client",
    "incorrect": [
      "Afficher tous les achats sans regroupement",
      "Supprimer les doublons dans la table achat",
      "Trier les achats par tarif"
    ]
  },
  {
    "question": "Quelle fonction d’agrégation serait la plus adaptée pour obtenir le prix de l’article le plus cher ?",
    "correct": "MAX()",
    "incorrect": [
      "COUNT()",
      "AVG()",
      "SUM()"
    ]
  },
  {
    "question": "Quelle est la différence entre COUNT(*) et COUNT(colonne) ?",
    "correct": "COUNT(*) compte toutes les lignes, COUNT(colonne) ignore les NULL",
    "incorrect": [
      "COUNT(*) ignore les doublons, COUNT(colonne) les inclut",
      "COUNT(colonne) est plus rapide que COUNT(*)",
      "Il n’y a aucune différence entre les deux"
    ]
  },
  {
    "question": "Quelle est la fonction SQL permettant de calculer la moyenne d'une colonne numérique ?",
    "correct": "AVG()",
    "incorrect": [
      "MEAN()",
      "SUM()",
      "AVERAGE()"
    ]
  },
  {
    "question": "Quelle est la bonne syntaxe pour calculer la moyenne des valeurs d'une colonne ?",
    "correct": "SELECT AVG(colonne) FROM table",
    "incorrect": [
      "SELECT MOYENNE(colonne) FROM table",
      "SELECT SUM(colonne) / COUNT(colonne) FROM table",
      "SELECT AVERAGE(colonne) FROM table"
    ]
  },
  {
    "question": "Que retourne la fonction AVG() en SQL ?",
    "correct": "La moyenne des valeurs numériques non nulles d'une colonne",
    "incorrect": [
      "Le total des valeurs numériques d'une colonne",
      "La valeur médiane d'une colonne",
      "La moyenne arrondie de toutes les valeurs"
    ]
  },
  {
    "question": "Quel mot-clé SQL est utilisé avec AVG() pour calculer la moyenne par groupe ?",
    "correct": "GROUP BY",
    "incorrect": [
      "ORDER BY",
      "FILTER BY",
      "PARTITION BY"
    ]
  },
  {
    "question": "Dans quel cas la fonction AVG() ignore une valeur d'une colonne ?",
    "correct": "Lorsque la valeur est NULL",
    "incorrect": [
      "Lorsque la valeur est 0",
      "Lorsque la valeur est négative",
      "Lorsque la valeur dépasse 1000"
    ]
  },
  {
    "question": "Quel est le résultat de la requête : SELECT AVG(tarif) FROM achat ?",
    "correct": "La moyenne des tarifs de tous les achats",
    "incorrect": [
      "Le tarif maximum des achats",
      "Le nombre total d’achats",
      "La somme des tarifs divisée par 2"
    ]
  },
  {
    "question": "Quelle fonction faut-il associer à GROUP BY pour obtenir une moyenne par client ?",
    "correct": "AVG()",
    "incorrect": [
      "COUNT()",
      "SUM()",
      "MIN()"
    ]
  },
  {
    "question": "Dans l’exemple donné, quel est le montant moyen d’achat de Marie ?",
    "correct": "19",
    "incorrect": [
      "18",
      "20",
      "38"
    ]
  },
  {
    "question": "Pourquoi la fonction AVG() est-elle utile en analyse de données ?",
    "correct": "Elle permet de résumer des valeurs numériques par leur moyenne",
    "incorrect": [
      "Elle permet de trier les valeurs par ordre croissant",
      "Elle supprime les doublons dans une table",
      "Elle remplace les valeurs NULL par 0"
    ]
  },
  {
    "question": "Quel SGBD ne supporte PAS la fonction AVG() ?",
    "correct": "Aucun, tous les SGBD majeurs la supportent",
    "incorrect": [
      "MySQL",
      "PostgreSQL",
      "SQL Server"
    ]
  },
  {
    "question": "Quelle fonction SQL permet de compter le nombre total de lignes dans une table ?",
    "correct": "COUNT(*)",
    "incorrect": [
      "SUM(*)",
      "TOTAL()",
      "COUNT_ALL()"
    ]
  },
  {
    "question": "Que retourne la requête : SELECT COUNT(*) FROM utilisateur ?",
    "correct": "Le nombre total d'enregistrements dans la table utilisateur",
    "incorrect": [
      "Le nombre total de colonnes de la table utilisateur",
      "La somme des valeurs numériques de la table utilisateur",
      "Le nombre de lignes non nulles de la table utilisateur"
    ]
  },
  {
    "question": "Quelle est la différence entre COUNT(*) et COUNT(nom_colonne) ?",
    "correct": "COUNT(nom_colonne) ignore les valeurs NULL",
    "incorrect": [
      "COUNT(*) ne fonctionne que sur les colonnes numériques",
      "COUNT(nom_colonne) compte aussi les lignes en double",
      "COUNT(*) ignore les doublons"
    ]
  },
  {
    "question": "Quel est le rôle de COUNT(DISTINCT nom_colonne) ?",
    "correct": "Compter le nombre de valeurs différentes dans une colonne",
    "incorrect": [
      "Compter les lignes non nulles dans une colonne",
      "Compter toutes les valeurs numériques d'une colonne",
      "Compter le nombre de colonnes distinctes dans une table"
    ]
  },
  {
    "question": "Quelle requête permet de compter le nombre d’utilisateurs ayant effectué au moins un achat ?",
    "correct": "SELECT COUNT(*) FROM utilisateur WHERE nombre_achat > 0",
    "incorrect": [
      "SELECT COUNT(*) FROM utilisateur WHERE nombre_achat = 0",
      "SELECT COUNT(nombre_achat) FROM utilisateur",
      "SELECT COUNT(*) FROM utilisateur GROUP BY nombre_achat"
    ]
  },
  {
    "question": "Quel sera le résultat de la requête : SELECT COUNT(id_dernier_achat) FROM utilisateur ?",
    "correct": "3",
    "incorrect": [
      "2",
      "5",
      "4"
    ]
  },
  {
    "question": "Quelle requête permet de connaître le nombre de villes différentes dans la table utilisateur ?",
    "correct": "SELECT COUNT(DISTINCT ville) FROM utilisateur",
    "incorrect": [
      "SELECT COUNT(*) FROM ville",
      "SELECT COUNT(ville) FROM utilisateur GROUP BY ville",
      "SELECT DISTINCT COUNT(ville) FROM utilisateur"
    ]
  },
  {
    "question": "Dans quel cas COUNT(nom_colonne) retourne une valeur inférieure à COUNT(*) ?",
    "correct": "Quand certaines lignes ont une valeur NULL dans la colonne",
    "incorrect": [
      "Quand la table contient moins de 1000 lignes",
      "Quand la colonne est une clé étrangère",
      "Quand la colonne est de type texte"
    ]
  },
  {
    "question": "Quelle clause SQL peut être utilisée avec COUNT() pour filtrer les résultats ?",
    "correct": "WHERE",
    "incorrect": [
      "SORT",
      "MERGE",
      "JOIN"
    ]
  },
  {
    "question": "Pourquoi utiliser COUNT(DISTINCT ville) plutôt que COUNT(ville) ?",
    "correct": "Pour ne compter qu’une seule fois chaque ville",
    "incorrect": [
      "Pour inclure les villes en double",
      "Pour ignorer les villes NULL",
      "Pour trier les villes par ordre alphabétique"
    ]
  },
  {
    "question": "Quelle est la fonction SQL utilisée pour récupérer la valeur maximale d'une colonne ?",
    "correct": "MAX()",
    "incorrect": [
      "TOP()",
      "GREATEST()",
      "HIGHEST()"
    ]
  },
  {
    "question": "Quel est le résultat de la requête : SELECT MAX(prix) FROM produit ?",
    "correct": "150",
    "incorrect": [
      "50",
      "120",
      "21"
    ]
  },
  {
    "question": "La fonction MAX() peut être utilisée avec quelles sortes de données ?",
    "correct": "Numériques et alphanumériques",
    "incorrect": [
      "Uniquement les chaînes de caractères",
      "Uniquement les valeurs numériques",
      "Uniquement les dates"
    ]
  },
  {
    "question": "Quelle requête permet d'obtenir le prix le plus élevé par type de produit ?",
    "correct": "SELECT nom, MAX(prix) FROM produit GROUP BY nom",
    "incorrect": [
      "SELECT nom, prix FROM produit WHERE prix = MAX()",
      "SELECT MAX(prix) GROUP BY nom FROM produit",
      "SELECT prix, MAX(nom) FROM produit GROUP BY prix"
    ]
  },
  {
    "question": "Quel est le rôle de la clause GROUP BY lorsqu’elle est utilisée avec MAX() ?",
    "correct": "Elle permet de calculer la valeur maximale pour chaque groupe",
    "incorrect": [
      "Elle empêche d’utiliser la fonction MAX()",
      "Elle trie les résultats par ordre croissant",
      "Elle renomme les colonnes avec la valeur maximale"
    ]
  },
  {
    "question": "Quel produit a le prix maximum dans l’exemple fourni ?",
    "correct": "disque dur",
    "incorrect": [
      "clavier",
      "souris",
      "écran"
    ]
  },
  {
    "question": "Pourquoi la requête SELECT id, nom, MAX(prix) FROM produit ne retourne qu’un seul résultat ?",
    "correct": "Parce que MAX(prix) agrège toutes les lignes sans GROUP BY",
    "incorrect": [
      "Parce que la requête contient une erreur",
      "Parce qu’il y a plusieurs produits avec le même prix",
      "Parce qu’elle est utilisée avec DISTINCT"
    ]
  },
  {
    "question": "Quelle serait une bonne manière d’obtenir toutes les colonnes du produit le plus cher ?",
    "correct": "Utiliser une sous-requête avec MAX(prix)",
    "incorrect": [
      "Utiliser GROUP BY sur toutes les colonnes",
      "Utiliser COUNT() à la place de MAX()",
      "Ajouter WHERE prix = MIN(prix)"
    ]
  },
  {
    "question": "Que retourne la fonction MAX() si la colonne contient uniquement des valeurs NULL ?",
    "correct": "NULL",
    "incorrect": [
      "0",
      "Erreur",
      "Une chaîne vide"
    ]
  },
  {
    "question": "Quelle fonction peut être combinée à MAX() pour obtenir des statistiques par groupe ?",
    "correct": "GROUP BY",
    "incorrect": [
      "ORDER BY",
      "HAVING ONLY",
      "DISTINCT ON"
    ]
  },
  {
    "question": "Quelle fonction SQL permet de récupérer la plus petite valeur d’une colonne ?",
    "correct": "MIN()",
    "incorrect": [
      "LOW()",
      "SMALLEST()",
      "MINIMUM()"
    ]
  },
  {
    "question": "Que retourne la requête : SELECT MIN(prix) FROM produits WHERE categorie = 'maison' ?",
    "correct": "200",
    "incorrect": [
      "450",
      "70",
      "980"
    ]
  },
  {
    "question": "Quel est le rôle principal de la fonction MIN() ?",
    "correct": "Retourner la plus petite valeur d'une colonne",
    "incorrect": [
      "Compter le nombre d'enregistrements",
      "Retourner la plus grande valeur d'une colonne",
      "Faire la somme des enregistrements"
    ]
  },
  {
    "question": "La fonction MIN() peut être utilisée avec quel type de données ?",
    "correct": "Numériques et alphanumériques",
    "incorrect": [
      "Uniquement numériques",
      "Uniquement alphanumériques",
      "Uniquement booléennes"
    ]
  },
  {
    "question": "Quelle requête permet de connaître la date du premier ajout d’un produit par catégorie ?",
    "correct": "SELECT categorie, MIN(date_ajout) FROM produits GROUP BY categorie",
    "incorrect": [
      "SELECT categorie, date_ajout FROM produits WHERE date_ajout = MIN()",
      "SELECT MIN(date_ajout), categorie FROM produits",
      "SELECT date_ajout FROM produits GROUP MIN BY categorie"
    ]
  },
  {
    "question": "Quel est le produit le moins cher dans la catégorie 'maison' ?",
    "correct": "Aspirateur",
    "incorrect": [
      "Canapé",
      "Imprimante",
      "Ordinateur"
    ]
  },
  {
    "question": "Quel est le résultat de MIN(date_ajout) pour la catégorie 'informatique' ?",
    "correct": "2013-01-24",
    "incorrect": [
      "2013-02-10",
      "2013-04-04",
      "2013-02-11"
    ]
  },
  {
    "question": "Que se passe-t-il si la fonction MIN() est utilisée sans clause WHERE ?",
    "correct": "Elle retourne la plus petite valeur sur l'ensemble de la table",
    "incorrect": [
      "Elle retourne une erreur",
      "Elle retourne uniquement les valeurs NULL",
      "Elle retourne la valeur la plus fréquente"
    ]
  },
  {
    "question": "Quelle commande complète le mieux MIN() pour obtenir une agrégation par catégorie ?",
    "correct": "GROUP BY",
    "incorrect": [
      "ORDER BY",
      "HAVING",
      "JOIN"
    ]
  },
  {
    "question": "Quelle fonction utiliser pour obtenir la date la plus récente d’ajout d’un produit ?",
    "correct": "MAX()",
    "incorrect": [
      "AVG()",
      "FIRST()",
      "TOP()"
    ]
  },
  {
    "question": "Quelle fonction SQL permet de calculer la somme des valeurs numériques d’une colonne ?",
    "correct": "SUM()",
    "incorrect": [
      "TOTAL()",
      "ADD()",
      "COUNT()"
    ]
  },
  {
    "question": "Que retourne la requête : SELECT SUM(prix) FROM facture WHERE facture_id = 1 ?",
    "correct": "39",
    "incorrect": [
      "32",
      "17",
      "71"
    ]
  },
  {
    "question": "Sur quel type de données la fonction SUM() peut-elle être utilisée ?",
    "correct": "Données numériques",
    "incorrect": [
      "Chaînes de caractères",
      "Valeurs booléennes",
      "Toutes les données"
    ]
  },
  {
    "question": "Que se passe-t-il si une colonne contient des valeurs NULL dans une requête avec SUM() ?",
    "correct": "Elles sont ignorées dans le calcul",
    "incorrect": [
      "Elles provoquent une erreur",
      "Elles sont considérées comme zéro",
      "Elles arrêtent le calcul"
    ]
  },
  {
    "question": "Quelle commande permet de calculer la somme des montants pour chaque facture ?",
    "correct": "GROUP BY facture_id",
    "incorrect": [
      "ORDER BY facture_id",
      "HAVING facture_id",
      "JOIN facture_id"
    ]
  },
  {
    "question": "Quel est le résultat de la requête : SELECT SUM(prix) FROM facture WHERE facture_id = 2 ?",
    "correct": "32",
    "incorrect": [
      "39",
      "17",
      "15"
    ]
  },
  {
    "question": "Que signifie le mot-clé AS dans la requête : SELECT SUM(prix) AS prix_total ?",
    "correct": "Il donne un alias à la colonne retournée",
    "incorrect": [
      "Il filtre les lignes nulles",
      "Il groupe les lignes similaires",
      "Il crée une nouvelle colonne"
    ]
  },
  {
    "question": "Quelle clause permet de limiter les lignes prises en compte par la fonction SUM() ?",
    "correct": "WHERE",
    "incorrect": [
      "HAVING",
      "LIMIT",
      "SELECT"
    ]
  },
  {
    "question": "Quel serait le résultat de la requête : SELECT SUM(prix) FROM facture ?",
    "correct": "71",
    "incorrect": [
      "39",
      "32",
      "54"
    ]
  },
  {
    "question": "Quelle combinaison de commandes permet d’obtenir le total des prix par facture ?",
    "correct": "SELECT facture_id, SUM(prix) FROM facture GROUP BY facture_id",
    "incorrect": [
      "SELECT facture_id FROM facture SUM(prix)",
      "SELECT facture_id GROUP BY SUM(prix) FROM facture",
      "SELECT SUM(prix) GROUP BY facture_id FROM facture"
    ]
  },
  {
    "question": "Quelle fonction SQL permet de concaténer plusieurs chaînes de caractères ?",
    "correct": "CONCAT()",
    "incorrect": [
      "MERGE()",
      "JOIN()",
      "UNION()"
    ]
  },
  {
    "question": "Quelle est la différence entre CHAR_LENGTH() et LENGTH() en SQL ?",
    "correct": "CHAR_LENGTH() compte les caractères, LENGTH() compte les octets",
    "incorrect": [
      "Aucune différence",
      "CHAR_LENGTH() compte les mots, LENGTH() compte les caractères",
      "CHAR_LENGTH() ne fonctionne que sur des chaînes numériques"
    ]
  },
  {
    "question": "Quelle fonction retourne la position d’un mot dans une liste séparée par des virgules ?",
    "correct": "FIND_IN_SET()",
    "incorrect": [
      "POSITION()",
      "INDEX()",
      "SEARCH()"
    ]
  },
  {
    "question": "Quelle fonction permet de remplacer une sous-chaîne dans une chaîne de caractères ?",
    "correct": "REPLACE()",
    "incorrect": [
      "REWRITE()",
      "SUBSTITUTE()",
      "CHANGE()"
    ]
  },
  {
    "question": "Quelle fonction retourne la version en majuscules d’une chaîne ?",
    "correct": "UPPER()",
    "incorrect": [
      "MAJ()",
      "CAPITALIZE()",
      "LCASE()"
    ]
  },
  {
    "question": "Quelle fonction retourne le nombre de caractères d'une chaîne ?",
    "correct": "CHAR_LENGTH()",
    "incorrect": [
      "WORD_COUNT()",
      "LENGTH_BYTES()",
      "SIZE()"
    ]
  },
  {
    "question": "Quelle fonction retourne la chaîne inversée ?",
    "correct": "REVERSE()",
    "incorrect": [
      "INVERT()",
      "FLIP()",
      "REVERT()"
    ]
  },
  {
    "question": "Quelle fonction permet de transformer une chaîne en minuscules ?",
    "correct": "LOWER()",
    "incorrect": [
      "MINUSCULE()",
      "TO_LOWER()",
      "LCASE()"
    ]
  },
  {
    "question": "Que fait la fonction TRIM() en SQL ?",
    "correct": "Elle supprime les espaces en début et fin de chaîne",
    "incorrect": [
      "Elle tronque la chaîne à 10 caractères",
      "Elle supprime toutes les voyelles",
      "Elle convertit la chaîne en entier"
    ]
  },
  {
    "question": "Quelle fonction permet de retourner les n premiers caractères d’une chaîne ?",
    "correct": "LEFT()",
    "incorrect": [
      "FIRST()",
      "TOP()",
      "HEAD()"
    ]
  },
  {
    "question": "Quelle fonction permet d’ajouter un séparateur lors de la concaténation de chaînes ?",
    "correct": "CONCAT_WS()",
    "incorrect": [
      "CONCAT_SEP()",
      "MERGE_WITH()",
      "JOIN_SEP()"
    ]
  },
  {
    "question": "Quelle fonction permet de compter les bits d'une chaîne ?",
    "correct": "BIT_LENGTH()",
    "incorrect": [
      "BYTE_SIZE()",
      "CHAR_BITS()",
      "BIT_COUNT()"
    ]
  },
  {
    "question": "Quelle fonction retourne la position d’un caractère dans une chaîne sous MySQL ?",
    "correct": "INSTR()",
    "incorrect": [
      "POSITION()",
      "SEARCH()",
      "LOCATE_CHAR()"
    ]
  },
  {
    "question": "Quelle fonction retourne un segment d’une chaîne de caractères ?",
    "correct": "SUBSTRING()",
    "incorrect": [
      "PART_OF()",
      "SPLIT()",
      "SLICE()"
    ]
  },
  {
    "question": "Quelle fonction est synonyme de CHAR_LENGTH() en SQL ?",
    "correct": "CHARACTER_LENGTH()",
    "incorrect": [
      "STRLEN()",
      "STRING_LENGTH()",
      "LEN()"
    ]
  },
  {
    "question": "Quelle fonction SQL permet de répéter une chaîne plusieurs fois ?",
    "correct": "REPEAT()",
    "incorrect": [
      "DUPLICATE()",
      "MULTIPLY()",
      "RECURSE()"
    ]
  },
  {
    "question": "Quelle fonction retourne la position d’une sous-chaîne ?",
    "correct": "POSITION()",
    "incorrect": [
      "PLACE()",
      "LOCATOR()",
      "FIND_AT()"
    ]
  },
  {
    "question": "Quelle fonction permet d’ajouter du contenu au début d’une chaîne jusqu’à une longueur donnée ?",
    "correct": "LPAD()",
    "incorrect": [
      "LADD()",
      "PREFIX()",
      "PADLEFT()"
    ]
  },
  {
    "question": "Quelle fonction retourne un caractère à partir de sa valeur ASCII ?",
    "correct": "CHAR()",
    "incorrect": [
      "ASCII_TO_CHAR()",
      "CODEPOINT()",
      "ORD()"
    ]
  },
  {
    "question": "Quelle fonction retourne le code ASCII du premier caractère d’une chaîne ?",
    "correct": "ASCII()",
    "incorrect": [
      "CHARCODE()",
      "ORD()",
      "CODE()"
    ]
  },
  {
    "question": "Quelle est l'utilité principale de la fonction SQL CONCAT() ?",
    "correct": "Assembler plusieurs valeurs pour créer une seule chaîne de caractères",
    "incorrect": [
      "Compter le nombre de colonnes dans une table",
      "Remplacer une chaîne de caractères par une autre",
      "Extraire une sous-chaîne d’un champ"
    ]
  },
  {
    "question": "Quelle est la bonne syntaxe pour concaténer deux colonnes dans une requête SQL ?",
    "correct": "CONCAT(colonne1, colonne2)",
    "incorrect": [
      "CONCATENATE(colonne1, colonne2)",
      "colonne1 + colonne2",
      "MERGE(colonne1, colonne2)"
    ]
  },
  {
    "question": "Quel est le rôle de l'espace ' ' dans cette expression : CONCAT(prenom, ' ', nom) ?",
    "correct": "Ajouter un espace entre le prénom et le nom",
    "incorrect": [
      "Remplacer les caractères spéciaux",
      "Supprimer les espaces inutiles",
      "Indiquer une colonne vide"
    ]
  },
  {
    "question": "Quelle fonction SQL permet de concaténer les champs `prenom` et `nom` avec un espace entre les deux ?",
    "correct": "CONCAT(prenom, ' ', nom)",
    "incorrect": [
      "JOIN(prenom, nom)",
      "MERGE(prenom, nom)",
      "GLUE(prenom, nom)"
    ]
  },
  {
    "question": "Que retourne la requête : SELECT CONCAT('Bonjour', ' ', 'le monde') ?",
    "correct": "Bonjour le monde",
    "incorrect": [
      "Bonjourle monde",
      "Bonjour, le monde",
      "Erreur de syntaxe"
    ]
  },
  {
    "question": "Dans quel contexte peut-on utiliser CONCAT() dans une clause WHERE ?",
    "correct": "Pour comparer une concaténation de colonnes avec une chaîne",
    "incorrect": [
      "Pour additionner des valeurs numériques",
      "Pour filtrer les lignes selon une date",
      "Pour supprimer les doublons dans une jointure"
    ]
  },
  {
    "question": "Que permet d’obtenir la requête : SELECT id FROM utilisateur WHERE CONCAT(prenom, ' ', nom) = 'Sabine Lemaire' ?",
    "correct": "L’identifiant de l’utilisateur nommé Sabine Lemaire",
    "incorrect": [
      "Toutes les utilisatrices prénommées Sabine",
      "Les noms contenant le mot Sabine",
      "Un tableau d’enregistrements vides"
    ]
  },
  {
    "question": "Pourquoi utiliser CONCAT() avec une date et une heure comme dans CONCAT('2013-08-27', ' 00:00:00') ?",
    "correct": "Pour reconstituer une valeur DATETIME complète à partir d’une date",
    "incorrect": [
      "Pour formater automatiquement une date",
      "Pour convertir une chaîne en entier",
      "Pour changer le fuseau horaire d'une date"
    ]
  },
  {
    "question": "La fonction CONCAT() peut-elle prendre plus de deux arguments ?",
    "correct": "Oui, elle accepte plusieurs arguments",
    "incorrect": [
      "Non, uniquement deux",
      "Uniquement si tous les champs sont numériques",
      "Seulement si GROUP BY est utilisé"
    ]
  },
  {
    "question": "Quelle est la différence entre CONCAT(col1, col2) et CONCAT(col1, ' ', col2) ?",
    "correct": "Le second ajoute un espace entre les deux colonnes",
    "incorrect": [
      "Le second convertit les colonnes en majuscules",
      "Aucune, les deux sont identiques",
      "Le premier retourne toujours NULL"
    ]
  },
  {
    "question": "Quel est le rôle de la fonction SQL LENGTH() ?",
    "correct": "Calculer le nombre d’octets d’une chaîne de caractères",
    "incorrect": [
      "Calculer le nombre de mots d’un champ",
      "Compter le nombre de colonnes dans une table",
      "Afficher les lignes contenant une chaîne longue"
    ]
  },
  {
    "question": "Quelle est la bonne syntaxe pour obtenir la longueur de la chaîne 'bonjour' ?",
    "correct": "SELECT LENGTH('bonjour');",
    "incorrect": [
      "SELECT LEN('bonjour');",
      "SELECT SIZE('bonjour');",
      "SELECT COUNT('bonjour');"
    ]
  },
  {
    "question": "Quelle fonction SQL équivaut à LENGTH() dans SQL Server ?",
    "correct": "LEN()",
    "incorrect": [
      "CHAR_LENGTH()",
      "SIZE()",
      "STRLEN()"
    ]
  },
  {
    "question": "Que retourne la requête : SELECT LENGTH('œuf') ?",
    "correct": "3",
    "incorrect": [
      "4",
      "5",
      "6"
    ]
  },
  {
    "question": "Quel est l’intérêt d’utiliser LENGTH(login) < 5 dans une clause WHERE ?",
    "correct": "Identifier les utilisateurs dont le login est court",
    "incorrect": [
      "Supprimer les doublons de login",
      "Afficher les logins contenant le chiffre 5",
      "Trier les utilisateurs par taille de login"
    ]
  },
  {
    "question": "Que renvoie la fonction LENGTH() appliquée à la valeur NULL ?",
    "correct": "NULL",
    "incorrect": [
      "0",
      "Une erreur",
      "La longueur maximale autorisée"
    ]
  },
  {
    "question": "Pourquoi utiliser LENGTH(telephone) < 10 dans une requête SQL ?",
    "correct": "Pour détecter les numéros de téléphone probablement incomplets",
    "incorrect": [
      "Pour calculer la somme des numéros",
      "Pour tronquer les numéros à 10 caractères",
      "Pour convertir le numéro en format texte"
    ]
  },
  {
    "question": "Quel résultat donne : SELECT LENGTH('SQL') ?",
    "correct": "3",
    "incorrect": [
      "2",
      "4",
      "1"
    ]
  },
  {
    "question": "Quelle fonction SQL permet d’afficher le nombre de caractères dans la colonne 'login' pour chaque ligne ?",
    "correct": "LENGTH(login)",
    "incorrect": [
      "SIZE(login)",
      "COUNT(login)",
      "MEASURE(login)"
    ]
  },
  {
    "question": "Quel est le résultat de LENGTH('06.00.00.00.00') ?",
    "correct": "14",
    "incorrect": [
      "10",
      "12",
      "13"
    ]
  },
  {
    "question": "Quel est le rôle principal de la fonction SQL REPLACE() ?",
    "correct": "Remplacer un texte spécifique par un autre dans une chaîne",
    "incorrect": [
      "Effacer une chaîne de caractères",
      "Ajouter une nouvelle colonne à une table",
      "Extraire une sous-chaîne d’un champ"
    ]
  },
  {
    "question": "Quel est le bon ordre des paramètres de la fonction REPLACE() en SQL ?",
    "correct": "Chaîne initiale, texte à remplacer, texte de remplacement",
    "incorrect": [
      "Texte à remplacer, texte de remplacement, chaîne initiale",
      "Texte de remplacement, chaîne initiale, texte à remplacer",
      "Chaîne initiale, texte de remplacement, texte à remplacer"
    ]
  },
  {
    "question": "Quel sera le résultat de la requête : SELECT REPLACE('bonjour tout le monde', 'bonjour', 'salut');",
    "correct": "salut tout le monde",
    "incorrect": [
      "bonjour tout le monde",
      "salut bonjour tout le monde",
      "tout le monde salut"
    ]
  },
  {
    "question": "Quelle commande permet de remplacer 'www.facebook.com' par 'fr-fr.facebook.com' dans une colonne 'url' ?",
    "correct": "REPLACE(url, 'www.facebook.com', 'fr-fr.facebook.com')",
    "incorrect": [
      "REPLACE('www.facebook.com', url, 'fr-fr.facebook.com')",
      "REPLACE('fr-fr.facebook.com', 'www.facebook.com', url)",
      "REPLACE('url', 'www.facebook.com', 'fr-fr.facebook.com')"
    ]
  },
  {
    "question": "Dans quelle clause peut-on utiliser la fonction REPLACE() pour modifier les données dans la base ?",
    "correct": "SET d’une commande UPDATE",
    "incorrect": [
      "FROM d’une commande SELECT",
      "INTO d’une commande INSERT",
      "GROUP BY d’une commande SELECT"
    ]
  },
  {
    "question": "Quelle commande REPLACE permettrait de censurer le mot 'insulte' dans la colonne commentaire ?",
    "correct": "REPLACE(commentaire, 'insulte', 'CENSURE')",
    "incorrect": [
      "REPLACE('CENSURE', 'insulte', commentaire)",
      "REPLACE('insulte', commentaire, 'CENSURE')",
      "REPLACE(commentaire, 'CENSURE', 'insulte')"
    ]
  },
  {
    "question": "Quel est l’effet d’utiliser REPLACE() dans une commande SELECT ?",
    "correct": "Afficher un contenu modifié sans changer les données",
    "incorrect": [
      "Modifier définitivement les données",
      "Supprimer la ligne concernée",
      "Créer un nouvel enregistrement"
    ]
  },
  {
    "question": "Quelle clause est utilisée pour cibler uniquement les lignes contenant un mot spécifique ?",
    "correct": "WHERE ... LIKE '%mot%'",
    "incorrect": [
      "ORDER BY ... LIKE",
      "GROUP BY ... REPLACE",
      "SELECT ... IN REPLACE"
    ]
  },
  {
    "question": "Quelle est la compatibilité de la fonction REPLACE en SQL ?",
    "correct": "Elle est compatible avec MySQL, PostgreSQL, Oracle et SQL Server",
    "incorrect": [
      "Uniquement disponible sous MySQL",
      "Uniquement disponible dans PHP",
      "Compatible uniquement avec les chaînes numériques"
    ]
  },
  {
    "question": "Pourquoi faut-il faire attention en utilisant REPLACE() si on vient du langage PHP ?",
    "correct": "L’ordre des paramètres est différent de str_replace() en PHP",
    "incorrect": [
      "REPLACE ne fonctionne pas avec des chaînes PHP",
      "PHP n’autorise pas la fonction REPLACE",
      "PHP exécute toujours une suppression au lieu d’un remplacement"
    ]
  },
  {
    "question": "Quel est le rôle principal de la fonction SQL SOUNDEX() ?",
    "correct": "Retourner un code phonétique basé sur la sonorité d'une chaîne",
    "incorrect": [
      "Remplacer les caractères spéciaux dans une chaîne",
      "Convertir une chaîne en majuscules",
      "Calculer la longueur d'une chaîne"
    ]
  },
  {
    "question": "Quel résultat retourne la requête : SELECT SOUNDEX('hello'); ?",
    "correct": "H400",
    "incorrect": [
      "HELLO",
      "H4L0",
      "HLL0"
    ]
  },
  {
    "question": "Quelle utilité a SOUNDEX() dans un moteur de recherche ?",
    "correct": "Permettre de retrouver un mot mal orthographié mais phonétiquement proche",
    "incorrect": [
      "Trier les mots par ordre alphabétique",
      "Filtrer les doublons exacts",
      "Compresser les chaînes de caractères"
    ]
  },
  {
    "question": "Quel sera le résultat de : SELECT SOUNDEX('john'), SOUNDEX('jone'); ?",
    "correct": "J500, J500",
    "incorrect": [
      "J400, J500",
      "J500, J600",
      "JH00, JN00"
    ]
  },
  {
    "question": "Pourquoi la fonction SOUNDEX() peut-elle poser problème pour le français ?",
    "correct": "Elle se base sur les sonorités anglaises",
    "incorrect": [
      "Elle ignore les accents",
      "Elle retourne toujours NULL pour les caractères spéciaux",
      "Elle remplace tous les caractères par des chiffres"
    ]
  },
  {
    "question": "Quel est le format de sortie d’un code SOUNDEX ?",
    "correct": "Une lettre suivie de trois chiffres",
    "incorrect": [
      "Un nombre à six chiffres",
      "Une chaîne de longueur variable",
      "Une série alphanumérique aléatoire"
    ]
  },
  {
    "question": "Quel est l’intérêt d’utiliser SOUNDEX dans une clause WHERE ?",
    "correct": "Comparer deux chaînes sur leur prononciation",
    "incorrect": [
      "Calculer la fréquence d’un mot",
      "Identifier les caractères spéciaux d’une chaîne",
      "Effectuer une recherche exacte"
    ]
  },
  {
    "question": "Dans quel cas la requête WHERE SOUNDEX(prenom) = SOUNDEX('jone') peut-elle retourner 'John' ?",
    "correct": "Parce que 'John' et 'Jone' ont le même code phonétique",
    "incorrect": [
      "Parce que la base contient un index phonétique",
      "Parce que les deux noms ont le même nombre de lettres",
      "Parce que 'jone' est une sous-chaîne de 'John'"
    ]
  },
  {
    "question": "La fonction SOUNDEX() est-elle sensible à la casse (majuscules/minuscules) ?",
    "correct": "Non, elle n’est pas sensible à la casse",
    "incorrect": [
      "Oui, elle distingue les majuscules des minuscules",
      "Uniquement sur les bases MySQL",
      "Uniquement si une collation est définie"
    ]
  },
  {
    "question": "Quel SGBD ne supporte pas nativement la fonction SOUNDEX() parmi les suivants ?",
    "correct": "Aucun, elle est supportée par MySQL, PostgreSQL, SQL Server et Oracle",
    "incorrect": [
      "MySQL",
      "PostgreSQL",
      "SQL Server"
    ]
  },
  {
    "question": "À quoi sert la fonction SQL SUBSTRING() ?",
    "correct": "À extraire une portion d’une chaîne de caractères",
    "incorrect": [
      "À trier une chaîne de caractères",
      "À convertir une chaîne en majuscules",
      "À remplacer des caractères dans une chaîne"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte pour extraire une portion d’une chaîne à partir du 3e caractère et sur 5 caractères ?",
    "correct": "SUBSTRING(chaine, 3, 5)",
    "incorrect": [
      "SUBSTRING(3, 5, chaine)",
      "SUBSTRING(chaine FROM 3 TO 5)",
      "SUBSTRING(chaine, 5, 3)"
    ]
  },
  {
    "question": "Quel sera le résultat de la requête : SELECT SUBSTR('FRANCE', 1, 2); ?",
    "correct": "FR",
    "incorrect": [
      "RA",
      "ANCE",
      "FRA"
    ]
  },
  {
    "question": "Quelle version de la fonction est compatible avec PostgreSQL : SUBSTRING(string FROM 3 FOR 5) ?",
    "correct": "Compatible",
    "incorrect": [
      "Incompatible",
      "Partiellement compatible",
      "Compatible uniquement avec SQL Server"
    ]
  },
  {
    "question": "Que permet de faire la requête : SELECT SUBSTR(nom_fr_fr, 3) FROM pays ?",
    "correct": "Extraire le texte à partir du 3e caractère jusqu’à la fin",
    "incorrect": [
      "Extraire les 3 premiers caractères",
      "Extraire uniquement la 3e lettre",
      "Compter les caractères"
    ]
  },
  {
    "question": "Quel est le principal alias de la fonction SUBSTRING() ?",
    "correct": "SUBSTR()",
    "incorrect": [
      "SUBSTRLEN()",
      "STRCUT()",
      "SPLIT()"
    ]
  },
  {
    "question": "Quelle est la bonne requête pour extraire les 2 premiers caractères de la colonne nom_fr_fr ?",
    "correct": "SUBSTR(nom_fr_fr, 1, 2)",
    "incorrect": [
      "SUBSTR(nom_fr_fr, 2)",
      "SUBSTRING(nom_fr_fr FROM 2)",
      "SUBSTRING(nom_fr_fr, 2, 1)"
    ]
  },
  {
    "question": "Quel SGBD utilise uniquement la version SUBSTRING(string, start, length) ?",
    "correct": "SQL Server",
    "incorrect": [
      "PostgreSQL",
      "MySQL",
      "Oracle"
    ]
  },
  {
    "question": "Quelle requête affiche 'LEMAGNE' à partir du mot 'ALLEMAGNE' ?",
    "correct": "SELECT SUBSTRING('ALLEMAGNE', 3);",
    "incorrect": [
      "SELECT SUBSTRING('ALLEMAGNE', 2, 3);",
      "SELECT SUBSTRING('ALLEMAGNE', 5, 2);",
      "SELECT SUBSTRING('ALLEMAGNE', 4, 4);"
    ]
  },
  {
    "question": "Dans l'exemple fourni, que retourne la colonne SUBSTR(nom_fr_fr, 1, 2) pour le pays 'ESPAGNE' ?",
    "correct": "ES",
    "incorrect": [
      "SP",
      "PAGNE",
      "ESP"
    ]
  },
  {
    "question": "Quel est le rôle de la fonction SQL LEFT() ?",
    "correct": "Extraire un nombre défini de caractères depuis le début d’une chaîne",
    "incorrect": [
      "Extraire les caractères après un mot",
      "Extraire un mot entier d’un texte",
      "Extraire les derniers caractères d’une chaîne"
    ]
  },
  {
    "question": "Quel est le résultat de la requête : SELECT LEFT('bonjour', 3);",
    "correct": "bon",
    "incorrect": [
      "jour",
      "bonjour",
      "onj"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte pour utiliser la fonction LEFT() ?",
    "correct": "LEFT(chaine, longueur)",
    "incorrect": [
      "LEFT(longueur, chaine)",
      "LEFT(chaine TO longueur)",
      "LEFT FROM(chaine, longueur)"
    ]
  },
  {
    "question": "Que retourne la requête : SELECT LEFT('abcdefghij', 0);",
    "correct": "Une chaîne vide",
    "incorrect": [
      "abcdefghij",
      "NULL",
      "a"
    ]
  },
  {
    "question": "Quel est le comportement de LEFT() si la longueur demandée est supérieure à la taille de la chaîne ?",
    "correct": "Elle retourne toute la chaîne",
    "incorrect": [
      "Elle retourne une erreur",
      "Elle coupe au dernier caractère disponible",
      "Elle retourne une chaîne vide"
    ]
  },
  {
    "question": "Quel résultat retourne la requête : SELECT LEFT('bonjour', -1);",
    "correct": "Une chaîne vide",
    "incorrect": [
      "Une erreur SQL",
      "b",
      "NULL"
    ]
  },
  {
    "question": "Quel est le résultat de LEFT('abcdefghij', NULL) ?",
    "correct": "NULL",
    "incorrect": [
      "''",
      "'abcdefghij'",
      "'a'"
    ]
  },
  {
    "question": "Si un SGBD ne supporte pas LEFT(), quelle fonction peut-on utiliser à la place ?",
    "correct": "SUBSTRING() ou SUBSTR()",
    "incorrect": [
      "TRIM()",
      "REPLACE()",
      "FORMAT()"
    ]
  },
  {
    "question": "Quelle fonction est équivalente à LEFT() mais agit sur la fin de la chaîne ?",
    "correct": "RIGHT()",
    "incorrect": [
      "END()",
      "LAST()",
      "TAIL()"
    ]
  },
  {
    "question": "Dans quel cas la fonction LEFT() retourne exactement la chaîne d’origine ?",
    "correct": "Lorsque la longueur demandée est supérieure ou égale à la taille de la chaîne",
    "incorrect": [
      "Lorsque la chaîne est vide",
      "Lorsque la longueur est nulle",
      "Lorsque le second paramètre est négatif"
    ]
  },
  {
    "question": "Quel est le rôle principal de la fonction SQL RIGHT() ?",
    "correct": "Extraire un nombre défini de caractères depuis la fin d’une chaîne",
    "incorrect": [
      "Extraire les caractères entre deux mots",
      "Extraire les caractères au début d’une chaîne",
      "Extraire une sous-chaîne après une virgule"
    ]
  },
  {
    "question": "Quel est le résultat de la requête : SELECT RIGHT('abcdef', 2);",
    "correct": "ef",
    "incorrect": [
      "ab",
      "cd",
      "abcdef"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte pour utiliser la fonction RIGHT() ?",
    "correct": "RIGHT(chaine, longueur)",
    "incorrect": [
      "RIGHT(longueur, chaine)",
      "RIGHT FROM(chaine, longueur)",
      "RIGHT(chaine TO longueur)"
    ]
  },
  {
    "question": "Que retourne la requête : SELECT RIGHT('sqltest', 0);",
    "correct": "Une chaîne vide",
    "incorrect": [
      "sqltest",
      "NULL",
      "t"
    ]
  },
  {
    "question": "Quel est le comportement de RIGHT() si la longueur demandée dépasse la taille de la chaîne ?",
    "correct": "Elle retourne toute la chaîne",
    "incorrect": [
      "Elle retourne une erreur",
      "Elle coupe au dernier caractère disponible",
      "Elle retourne une chaîne vide"
    ]
  },
  {
    "question": "Quel est le résultat de RIGHT('abcdefghij', -1) ?",
    "correct": "Une chaîne vide",
    "incorrect": [
      "'j'",
      "'abcdefghij'",
      "NULL"
    ]
  },
  {
    "question": "Quel est le résultat de RIGHT('abcdef', NULL) ?",
    "correct": "NULL",
    "incorrect": [
      "'abcdef'",
      "''",
      "'a'"
    ]
  },
  {
    "question": "Si RIGHT() n’est pas disponible dans un SGBD, quelle fonction permet d'obtenir un résultat équivalent ?",
    "correct": "SUBSTRING() ou SUBSTR()",
    "incorrect": [
      "TRIM()",
      "LENGTH()",
      "REPLACE()"
    ]
  },
  {
    "question": "Quelle fonction SQL est similaire à RIGHT() mais agit sur le début de la chaîne ?",
    "correct": "LEFT()",
    "incorrect": [
      "FIRST()",
      "START()",
      "BEGIN()"
    ]
  },
  {
    "question": "Dans quel cas RIGHT() retourne exactement la chaîne d’origine ?",
    "correct": "Lorsque la longueur demandée est supérieure ou égale à la taille de la chaîne",
    "incorrect": [
      "Lorsque la chaîne est vide",
      "Lorsque la longueur est égale à zéro",
      "Lorsque le paramètre longueur est négatif"
    ]
  },
  {
    "question": "Quel est le rôle principal de la fonction SQL REVERSE() ?",
    "correct": "Inverser l’ordre des caractères d’une chaîne",
    "incorrect": [
      "Remplacer une chaîne par une autre",
      "Extraire une partie d’une chaîne",
      "Convertir une chaîne en majuscules"
    ]
  },
  {
    "question": "Quel est le résultat de la requête : SELECT REVERSE('SQL');",
    "correct": "LQS",
    "incorrect": [
      "SLQ",
      "S-L-Q",
      "QSL"
    ]
  },
  {
    "question": "Quelle est la syntaxe correcte pour inverser une chaîne ?",
    "correct": "REVERSE(chaine)",
    "incorrect": [
      "REVERSE FROM chaine",
      "REVERSE(chaine, 1)",
      "INVERSE(chaine)"
    ]
  },
  {
    "question": "Quel est le résultat de : SELECT REVERSE('123456');",
    "correct": "654321",
    "incorrect": [
      "123456",
      "543216",
      "321456"
    ]
  },
  {
    "question": "Que retourne la fonction REVERSE() lorsqu’elle reçoit une chaîne vide ('') ?",
    "correct": "Une chaîne vide",
    "incorrect": [
      "NULL",
      "Un espace",
      "Une erreur"
    ]
  },
  {
    "question": "Quel est le résultat de : SELECT REVERSE('bonjour le monde');",
    "correct": "ednom el ruojnob",
    "incorrect": [
      "ednom le ruojnob",
      "ruojnob el ednom",
      "ednom el bonjour"
    ]
  },
  {
    "question": "La fonction REVERSE() est compatible avec quels SGBD ?",
    "correct": "MySQL, PostgreSQL et SQL Server",
    "incorrect": [
      "Uniquement Oracle",
      "Uniquement PostgreSQL",
      "Uniquement MySQL"
    ]
  },
  {
    "question": "Quel est le résultat de REVERSE('racecar') ?",
    "correct": "racecar",
    "incorrect": [
      "raccera",
      "raceca",
      "racecarr"
    ]
  },
  {
    "question": "REVERSE() peut-elle inverser des caractères multi-octets comme “œ” ?",
    "correct": "Oui",
    "incorrect": [
      "Non, cela provoque une erreur",
      "Uniquement dans SQL Server",
      "Uniquement si la chaîne contient des chiffres"
    ]
  },
  {
    "question": "Quel est le principal intérêt d’utiliser REVERSE() ?",
    "correct": "Manipuler des chaînes pour des comparaisons ou des traitements spécifiques",
    "incorrect": [
      "Obtenir la longueur d’une chaîne",
      "Chercher une sous-chaîne",
      "Mettre des caractères en majuscules"
    ]
  },
  {
    "question": "Quel est le rôle principal de la fonction SQL TRIM() ?",
    "correct": "Supprimer les caractères invisibles au début et à la fin d’une chaîne",
    "incorrect": [
      "Ajouter des caractères à une chaîne",
      "Remplacer un mot par un autre",
      "Inverser une chaîne de caractères"
    ]
  },
  {
    "question": "Quel est le résultat de : SELECT TRIM('   Bonjour   ') ?",
    "correct": "Bonjour",
    "incorrect": [
      "   Bonjour",
      "Bonjour   ",
      "   Bonjour   "
    ]
  },
  {
    "question": "Quelle commande supprime uniquement les caractères 'x' au début d’une chaîne ?",
    "correct": "TRIM(LEADING 'x' FROM 'xxxTestxxx')",
    "incorrect": [
      "TRIM(TRAILING 'x' FROM 'xxxTestxxx')",
      "TRIM(BOTH 'x' FROM 'xxxTestxxx')",
      "TRIM('x', 'xxxTestxxx')"
    ]
  },
  {
    "question": "Quelle syntaxe permet de supprimer les caractères 'x' uniquement à la fin d’une chaîne ?",
    "correct": "TRIM(TRAILING 'x' FROM 'xxxTestxxx')",
    "incorrect": [
      "TRIM(LEADING 'x' FROM 'xxxTestxxx')",
      "TRIM('xxxTestxxx', 'x')",
      "TRIM(ENDING 'x' FROM 'xxxTestxxx')"
    ]
  },
  {
    "question": "Quelle est la différence entre TRIM() et LTRIM() ?",
    "correct": "TRIM() agit sur les deux côtés, LTRIM() uniquement au début",
    "incorrect": [
      "TRIM() agit seulement au début, LTRIM() sur les deux côtés",
      "Aucune différence",
      "LTRIM() agit sur la fin uniquement"
    ]
  },
  {
    "question": "Quel est le résultat de : TRIM(BOTH 'x' FROM 'xxxHello Worldxxx') ?",
    "correct": "Hello World",
    "incorrect": [
      "xxxHello World",
      "Hello Worldxxx",
      "xHello Worldx"
    ]
  },
  {
    "question": "Quelle syntaxe est utilisée par SQLite pour supprimer les 'x' au début et à la fin ?",
    "correct": "TRIM('x', 'xxxExemplexxx')",
    "incorrect": [
      "TRIM(BOTH 'x' FROM 'xxxExemplexxx')",
      "TRIM('xxxExemplexxx', 'x')",
      "TRIM('xxxExemplexxx')"
    ]
  },
  {
    "question": "Dans quels cas la fonction TRIM() est-elle utile ?",
    "correct": "Pour nettoyer les espaces et caractères invisibles dans les chaînes",
    "incorrect": [
      "Pour trier les données par ordre alphabétique",
      "Pour chiffrer les données sensibles",
      "Pour concaténer deux colonnes"
    ]
  },
  {
    "question": "Quel est le résultat de TRIM('     ') (une chaîne contenant uniquement des espaces) ?",
    "correct": "Une chaîne vide",
    "incorrect": [
      "NULL",
      "Une erreur",
      "Un espace"
    ]
  },
  {
    "question": "Quelles fonctions sont similaires à TRIM() ?",
    "correct": "LTRIM() et RTRIM()",
    "incorrect": [
      "UPPER() et LOWER()",
      "REVERSE() et REPLACE()",
      "LEFT() et RIGHT()"
    ]
  },
  {
    "question": "Quel est le rôle principal de la fonction SQL LTRIM() ?",
    "correct": "Supprimer les caractères invisibles au début d’une chaîne",
    "incorrect": [
      "Supprimer les caractères invisibles à la fin d’une chaîne",
      "Supprimer tous les caractères d’une chaîne",
      "Ajouter des espaces au début d’une chaîne"
    ]
  },
  {
    "question": "Quel est le résultat de : SELECT LTRIM('   Exemple   ') ?",
    "correct": "Exemple   ",
    "incorrect": [
      "   Exemple",
      "Exemple",
      "   Exemple   "
    ]
  },
  {
    "question": "Quel est le comportement de LTRIM() lorsqu’un caractère spécifique est précisé dans PostgreSQL ?",
    "correct": "Il supprime ce caractère uniquement au début de la chaîne",
    "incorrect": [
      "Il supprime ce caractère partout dans la chaîne",
      "Il supprime ce caractère uniquement à la fin",
      "Il remplace le caractère par un espace"
    ]
  },
  {
    "question": "Quel est le résultat de : SELECT LTRIM('xxxExemplexxx', 'x') ?",
    "correct": "Exemplexxx",
    "incorrect": [
      "xxxExemple",
      "Exemple",
      "xxExemplexx"
    ]
  },
  {
    "question": "Quelle fonction est utilisée pour supprimer uniquement les espaces à la fin d’une chaîne ?",
    "correct": "RTRIM()",
    "incorrect": [
      "TRIM()",
      "LEFT()",
      "SUBSTRING()"
    ]
  },
  {
    "question": "Quelle fonction supprime à la fois les espaces au début et à la fin d’une chaîne ?",
    "correct": "TRIM()",
    "incorrect": [
      "LTRIM()",
      "RTRIM()",
      "REMOVE()"
    ]
  },
  {
    "question": "Si la chaîne d’origine est '\\n\\nMessage', quel sera le résultat de LTRIM() ?",
    "correct": "Message",
    "incorrect": [
      "\\nMessage",
      "\\n\\nMessage",
      "Message\\n"
    ]
  },
  {
    "question": "Quels SGBD permettent d’utiliser LTRIM() avec un deuxième paramètre ?",
    "correct": "PostgreSQL, Oracle, SQLite",
    "incorrect": [
      "MySQL, SQL Server, Firebird",
      "SQL Server, SQLite, MySQL",
      "Oracle, MySQL, Firebird"
    ]
  },
  {
    "question": "Pourquoi utiliser LTRIM() dans une requête SELECT ?",
    "correct": "Pour afficher les résultats sans espaces au début",
    "incorrect": [
      "Pour supprimer une ligne entière",
      "Pour crypter une colonne",
      "Pour remplacer un mot par un autre"
    ]
  },
  {
    "question": "Quelle est la différence entre LTRIM() et TRIM() ?",
    "correct": "LTRIM() supprime au début, TRIM() supprime au début et à la fin",
    "incorrect": [
      "LTRIM() supprime au début et à la fin, TRIM() supprime tout",
      "Aucune, ce sont des synonymes",
      "TRIM() ne fonctionne que sur SQL Server"
    ]
  },
  {
    "question": "Quel est le rôle principal de la fonction SQL RTRIM() ?",
    "correct": "Supprimer les caractères invisibles à la fin d’une chaîne",
    "incorrect": [
      "Supprimer tous les caractères d’une chaîne",
      "Supprimer les caractères invisibles au début d’une chaîne",
      "Inverser l’ordre des caractères d’une chaîne"
    ]
  },
  {
    "question": "Quel est le résultat de : SELECT RTRIM('   Exemple   ') ?",
    "correct": "   Exemple",
    "incorrect": [
      "Exemple   ",
      "Exemple",
      "   Exemple   "
    ]
  },
  {
    "question": "Quel est le comportement de RTRIM() dans PostgreSQL lorsqu’un second paramètre est spécifié ?",
    "correct": "Il supprime le caractère indiqué uniquement à la fin de la chaîne",
    "incorrect": [
      "Il supprime tous les caractères identiques dans la chaîne",
      "Il remplace le caractère indiqué par un espace",
      "Il supprime le caractère seulement s’il est au début"
    ]
  },
  {
    "question": "Quel est le résultat de : SELECT RTRIM('xxxExemplexxx', 'x') ?",
    "correct": "xxxExemple",
    "incorrect": [
      "Exemplexxx",
      "Exemple",
      "xxExemplexx"
    ]
  },
  {
    "question": "Quelle fonction permet de supprimer les caractères invisibles au début d’une chaîne ?",
    "correct": "LTRIM()",
    "incorrect": [
      "TRIM()",
      "LEFT()",
      "REVERSE()"
    ]
  },
  {
    "question": "Quelle fonction permet de supprimer les caractères invisibles au début et à la fin d’une chaîne ?",
    "correct": "TRIM()",
    "incorrect": [
      "SUBSTR()",
      "RTRIM()",
      "LEFT()"
    ]
  },
  {
    "question": "Pourquoi utiliser RTRIM() dans une requête SQL sur des messages ?",
    "correct": "Pour supprimer les retours à la ligne à la fin du contenu",
    "incorrect": [
      "Pour limiter la taille des messages à 10 caractères",
      "Pour formater automatiquement les dates",
      "Pour traduire le contenu des messages"
    ]
  },
  {
    "question": "Quel est l’effet de RTRIM() sur une chaîne contenant uniquement des espaces à la fin ?",
    "correct": "Les espaces à la fin sont supprimés",
    "incorrect": [
      "Les espaces en début de chaîne sont supprimés",
      "Toute la chaîne est supprimée",
      "Un caractère spécial est ajouté à la fin"
    ]
  },
  {
    "question": "Quels SGBD permettent d’utiliser RTRIM() avec un deuxième paramètre ?",
    "correct": "PostgreSQL, Oracle, SQLite",
    "incorrect": [
      "MySQL, SQL Server, Firebird",
      "SQL Server, SQLite, MySQL",
      "Oracle, MySQL, Firebird"
    ]
  },
  {
    "question": "Quelle est la différence entre RTRIM() et TRIM() ?",
    "correct": "RTRIM() supprime à la fin, TRIM() supprime au début et à la fin",
    "incorrect": [
      "RTRIM() supprime toute la chaîne, TRIM() supprime seulement les espaces",
      "TRIM() supprime uniquement les caractères visibles",
      "Il n’y a aucune différence"
    ]
  },
  {
    "question": "Quel est le rôle principal de la fonction SQL LPAD() ?",
    "correct": "Compléter une chaîne en ajoutant des caractères au début",
    "incorrect": [
      "Compléter une chaîne en ajoutant des caractères à la fin",
      "Supprimer les caractères d’une chaîne",
      "Remplacer une chaîne par une autre"
    ]
  },
  {
    "question": "Que retourne l'instruction SQL : SELECT LPAD('azerty', 10, 'x') ?",
    "correct": "xxxxazerty",
    "incorrect": [
      "azertyxxxx",
      "azerty",
      "xxxxxazerty"
    ]
  },
  {
    "question": "Quel est le résultat de : SELECT LPAD('azerty', 4, 'x') ?",
    "correct": "azer",
    "incorrect": [
      "xtex",
      "xxxx",
      "azerty"
    ]
  },
  {
    "question": "Que se passe-t-il si la longueur souhaitée dans LPAD() est inférieure à la taille de la chaîne ?",
    "correct": "La chaîne est tronquée pour respecter la longueur souhaitée",
    "incorrect": [
      "La chaîne reste inchangée",
      "Une erreur est renvoyée",
      "Des espaces sont ajoutés à la fin"
    ]
  },
  {
    "question": "Quel est le troisième paramètre dans la fonction LPAD() ?",
    "correct": "La chaîne de complétion",
    "incorrect": [
      "La chaîne à supprimer",
      "Le nombre de caractères à ignorer",
      "Le type de retour souhaité"
    ]
  },
  {
    "question": "Quel est le résultat de : SELECT LPAD('123', 6, '0') ?",
    "correct": "000123",
    "incorrect": [
      "123000",
      "00123",
      "0000123"
    ]
  },
  {
    "question": "Sur quel SGBD la fonction LPAD() fonctionne sans le troisième paramètre ?",
    "correct": "PostgreSQL",
    "incorrect": [
      "MySQL",
      "SQLite",
      "SQL Server"
    ]
  },
  {
    "question": "Quel est le comportement de LPAD('azerty', 9, 'xy') ?",
    "correct": "xyxazerty",
    "incorrect": [
      "xyxyazerty",
      "azertyxyx",
      "azertyxyxy"
    ]
  },
  {
    "question": "Quel est le rôle de LPAD() dans l’exemple avec les prix au format numérique ?",
    "correct": "Formater le prix avec des zéros pour obtenir une chaîne de 8 caractères",
    "incorrect": [
      "Remplacer les virgules par des zéros",
      "Arrondir le prix au centime supérieur",
      "Convertir le prix en pourcentage"
    ]
  },
  {
    "question": "Quelle fonction permettrait d’ajouter des caractères à la fin d’une chaîne au lieu du début ?",
    "correct": "RPAD()",
    "incorrect": [
      "LTRIM()",
      "CONCAT()",
      "LEFT()"
    ]
  },
  {
    "question": "Quel est le rôle principal de la fonction SQL UPPER() ?",
    "correct": "Convertir une chaîne de caractères en majuscules",
    "incorrect": [
      "Convertir une chaîne de caractères en minuscules",
      "Extraire les majuscules d’une chaîne",
      "Supprimer les accents d’une chaîne"
    ]
  },
  {
    "question": "Quelle est la sortie de la requête : SELECT UPPER('Exemple') ?",
    "correct": "EXEMPLE",
    "incorrect": [
      "exemple",
      "Exemple",
      "EXemple"
    ]
  },
  {
    "question": "Quelle fonction est un alias de UPPER() dans MySQL et Oracle ?",
    "correct": "UCASE()",
    "incorrect": [
      "TOUPPER()",
      "MAJ()",
      "CAPITALIZE()"
    ]
  },
  {
    "question": "Quel est le résultat de : SELECT UPPER('élève') ?",
    "correct": "ÉLÈVE",
    "incorrect": [
      "Élève",
      "élève",
      "ELEVE"
    ]
  },
  {
    "question": "Sur quel encodage se base UPPER() par défaut dans MySQL ?",
    "correct": "ISO 8859-1 Latin1",
    "incorrect": [
      "UTF-8",
      "ASCII",
      "Windows-1252"
    ]
  },
  {
    "question": "Quelle clause SQL peut inclure la fonction UPPER() pour filtrer une requête ?",
    "correct": "WHERE",
    "incorrect": [
      "ORDER BY",
      "GROUP BY",
      "HAVING"
    ]
  },
  {
    "question": "Pourquoi utiliser UPPER() dans une clause WHERE ?",
    "correct": "Pour comparer des chaînes sans tenir compte de la casse",
    "incorrect": [
      "Pour filtrer uniquement les majuscules",
      "Pour exclure les accents",
      "Pour tronquer la chaîne avant la comparaison"
    ]
  },
  {
    "question": "Quelle fonction permet de faire l'inverse de UPPER() ?",
    "correct": "LOWER()",
    "incorrect": [
      "DOWNCASE()",
      "MINUSCULE()",
      "TOLOWER()"
    ]
  },
  {
    "question": "Que retourne la requête : SELECT UPPER(prenom) FROM utilisateur WHERE id = 2 ?",
    "correct": "BENJAMIN",
    "incorrect": [
      "benjamin",
      "Benjamin",
      "B-e-n-j-a-m-i-n"
    ]
  },
  {
    "question": "Quel est l’avantage d’utiliser UPPER() dans un moteur de recherche d’utilisateur ?",
    "correct": "Cela permet d’ignorer les différences entre majuscules et minuscules dans la recherche",
    "incorrect": [
      "Cela améliore les performances du tri",
      "Cela permet de trier par ordre alphabétique",
      "Cela anonymise les résultats"
    ]
  },
  {
    "question": "Quel est le rôle principal de la fonction SQL LOWER() ?",
    "correct": "Convertir une chaîne de caractères en minuscules",
    "incorrect": [
      "Convertir une chaîne de caractères en majuscules",
      "Supprimer les accents d’une chaîne",
      "Remplacer les espaces par des tirets"
    ]
  },
  {
    "question": "Quel est le résultat de : SELECT LOWER('BONJOUR tout le monde') ?",
    "correct": "bonjour tout le monde",
    "incorrect": [
      "Bonjour tout le monde",
      "BONJOUR TOUT LE MONDE",
      "bonjour Tout Le Monde"
    ]
  },
  {
    "question": "Quel est l’alias de la fonction LOWER() dans MySQL et Oracle ?",
    "correct": "LCASE()",
    "incorrect": [
      "TOLOWER()",
      "MINUSCULE()",
      "DOWNCASE()"
    ]
  },
  {
    "question": "Quel est l'encodage utilisé par défaut par la fonction LOWER() dans MySQL ?",
    "correct": "ISO 8859-1 Latin1",
    "incorrect": [
      "UTF-8",
      "ASCII",
      "Unicode"
    ]
  },
  {
    "question": "Quelle fonction SQL est équivalente à strtolower() en PHP ?",
    "correct": "LOWER()",
    "incorrect": [
      "UPPER()",
      "LENGTH()",
      "INITCAP()"
    ]
  },
  {
    "question": "Que permet la fonction LOWER() dans une clause WHERE ?",
    "correct": "Comparer des chaînes sans tenir compte de la casse",
    "incorrect": [
      "Convertir une date en texte",
      "Supprimer les doublons",
      "Filtrer uniquement les minuscules"
    ]
  },
  {
    "question": "Pourquoi utiliser LOWER() dans une requête de recherche ?",
    "correct": "Pour uniformiser la casse entre la base et la saisie utilisateur",
    "incorrect": [
      "Pour accélérer les performances de la requête",
      "Pour exclure les noms contenant des majuscules",
      "Pour afficher les résultats de manière aléatoire"
    ]
  },
  {
    "question": "Quel est le résultat de : SELECT LOWER('ÉLÈVE') ?",
    "correct": "élève",
    "incorrect": [
      "ELEVE",
      "ÉLÈVE",
      "Eleve"
    ]
  },
  {
    "question": "Quel est l'effet de LOWER(prenom) sur le prénom 'Benjamin' ?",
    "correct": "benjamin",
    "incorrect": [
      "Benjamin",
      "BENJAMIN",
      "BenJamin"
    ]
  },
  {
    "question": "Quelle fonction permet de faire l’inverse de LOWER() ?",
    "correct": "UPPER()",
    "incorrect": [
      "REVERSE()",
      "LTRIM()",
      "INITCAP()"
    ]
  },
  {
    "question": "Quel est le rôle principal de la fonction SQL UCASE() ?",
    "correct": "Convertir une chaîne de caractères en majuscules",
    "incorrect": [
      "Convertir une chaîne de caractères en minuscules",
      "Remplacer les accents dans une chaîne",
      "Supprimer les espaces dans une chaîne"
    ]
  },
  {
    "question": "Quelle autre fonction SQL est équivalente à UCASE() ?",
    "correct": "UPPER()",
    "incorrect": [
      "LCASE()",
      "INITCAP()",
      "TITLECASE()"
    ]
  },
  {
    "question": "Quel est le résultat de : SELECT UCASE('Exemple') ?",
    "correct": "EXEMPLE",
    "incorrect": [
      "exemple",
      "Exemple",
      "EXemple"
    ]
  },
  {
    "question": "Dans quels SGBD la fonction UCASE() est-elle disponible ?",
    "correct": "MySQL et Oracle",
    "incorrect": [
      "PostgreSQL et SQLite",
      "SQL Server et Firebird",
      "PostgreSQL et SQL Server"
    ]
  },
  {
    "question": "Quelle est l’utilité de UCASE() dans une clause WHERE ?",
    "correct": "Effectuer une comparaison sans tenir compte de la casse",
    "incorrect": [
      "Filtrer uniquement les majuscules",
      "Ignorer les doublons",
      "Optimiser les performances"
    ]
  },
  {
    "question": "Quel est le résultat de UCASE(prenom) si le prénom est 'Cosette' ?",
    "correct": "COSETTE",
    "incorrect": [
      "cosette",
      "Cosette",
      "COSette"
    ]
  },
  {
    "question": "Quelle fonction permet de faire l’inverse de UCASE() ?",
    "correct": "LCASE()",
    "incorrect": [
      "LOWCASE()",
      "MINUSCULE()",
      "LOWERCASE()"
    ]
  },
  {
    "question": "Quel est le principal inconvénient de la fonction UCASE() ?",
    "correct": "Elle n’est pas compatible avec tous les SGBD",
    "incorrect": [
      "Elle modifie les données en base",
      "Elle ne fonctionne qu’avec des chiffres",
      "Elle retourne toujours une erreur"
    ]
  },
  {
    "question": "Pourquoi utiliser UCASE() dans une application web ?",
    "correct": "Pour uniformiser l’affichage ou faciliter les recherches",
    "incorrect": [
      "Pour crypter les données utilisateurs",
      "Pour générer des mots de passe",
      "Pour formater les dates"
    ]
  },
  {
    "question": "Quel langage de programmation utilise aussi une fonction similaire à UCASE() ?",
    "correct": "JavaScript avec toUpperCase()",
    "incorrect": [
      "Python avec toMajuscule()",
      "C avec upString()",
      "PHP avec strupper()"
    ]
  },
  {
    "question": "Quel est le rôle principal de la fonction SQL LCASE() ?",
    "correct": "Convertir une chaîne de caractères en minuscules",
    "incorrect": [
      "Convertir une chaîne en majuscules",
      "Supprimer les espaces d’une chaîne",
      "Remplacer les caractères accentués"
    ]
  },
  {
    "question": "Quelle fonction SQL est équivalente à LCASE() ?",
    "correct": "LOWER()",
    "incorrect": [
      "UPPER()",
      "LSTRING()",
      "MIN()"
    ]
  },
  {
    "question": "Quel sera le résultat de SELECT LCASE('Exemple MAJUSCULE') ?",
    "correct": "exemple majuscule",
    "incorrect": [
      "Exemple majuscule",
      "EXEMPLE MAJUSCULE",
      "exemple MAJUSCULE"
    ]
  },
  {
    "question": "Dans quels SGBD la fonction LCASE() est-elle disponible ?",
    "correct": "MySQL et Oracle",
    "incorrect": [
      "PostgreSQL et SQL Server",
      "SQLite et Firebird",
      "PostgreSQL et SQLite"
    ]
  },
  {
    "question": "Quel est l’intérêt d’utiliser LCASE() dans une requête SELECT ?",
    "correct": "Afficher les résultats uniformément en minuscules",
    "incorrect": [
      "Filtrer les doublons",
      "Optimiser les performances de jointures",
      "Supprimer les lignes en double"
    ]
  },
  {
    "question": "Quelle est la différence entre LCASE() et UCASE() ?",
    "correct": "LCASE() convertit en minuscules, UCASE() en majuscules",
    "incorrect": [
      "LCASE() supprime les caractères spéciaux",
      "UCASE() est plus rapide",
      "LCASE() modifie les données en base"
    ]
  },
  {
    "question": "Quel est le résultat de LCASE(nom) si nom vaut 'TELLiER' ?",
    "correct": "tellier",
    "incorrect": [
      "Tellier",
      "TELLiER",
      "TELLier"
    ]
  },
  {
    "question": "Pourquoi utiliser LCASE() dans une clause WHERE ?",
    "correct": "Pour faire une comparaison insensible à la casse",
    "incorrect": [
      "Pour supprimer les lignes vides",
      "Pour convertir une colonne en entier",
      "Pour trier les données numériquement"
    ]
  },
  {
    "question": "Quelle alternative à LCASE() peut-on utiliser dans PostgreSQL ?",
    "correct": "LOWER()",
    "incorrect": [
      "LSTR()",
      "TO_LOWER()",
      "MINCASE()"
    ]
  },
  {
    "question": "Quel langage possède une fonction équivalente à LCASE() ?",
    "correct": "JavaScript avec toLowerCase()",
    "incorrect": [
      "C avec strtolower()",
      "SQL avec LOWERCASE()",
      "HTML avec lower()"
    ]
  },
  {
    "question": "Quel est le rôle principal de la fonction SQL LOCATE() ?",
    "correct": "Chercher la position d’une chaîne dans une autre chaîne",
    "incorrect": [
      "Remplacer une chaîne par une autre",
      "Découper une chaîne en plusieurs morceaux",
      "Compter le nombre de caractères"
    ]
  },
  {
    "question": "Que retourne LOCATE() si la chaîne recherchée n’est pas trouvée ?",
    "correct": "0",
    "incorrect": [
      "-1",
      "NULL",
      "Une erreur"
    ]
  },
  {
    "question": "Quel est l’équivalent de LOCATE() sous SQL Server ?",
    "correct": "CHARINDEX()",
    "incorrect": [
      "FIND_IN_STRING()",
      "POSITION()",
      "INSTR()"
    ]
  },
  {
    "question": "Quel est le résultat de LOCATE('mètre', 'kilomètre') ?",
    "correct": "5",
    "incorrect": [
      "4",
      "6",
      "1"
    ]
  },
  {
    "question": "Que permet le troisième paramètre de LOCATE() ?",
    "correct": "Définir la position de départ de la recherche",
    "incorrect": [
      "Limiter la longueur de la chaîne de sortie",
      "Remplacer les caractères trouvés",
      "Compter le nombre d’occurrences"
    ]
  },
  {
    "question": "Quelle fonction PHP est équivalente à LOCATE() ?",
    "correct": "strpos()",
    "incorrect": [
      "substr()",
      "strlen()",
      "explode()"
    ]
  },
  {
    "question": "Que retourne LOCATE('test', 'unitetest', 5) ?",
    "correct": "6",
    "incorrect": [
      "1",
      "0",
      "5"
    ]
  },
  {
    "question": "Si on exécute LOCATE('mm', 'millimètre'), quel sera le résultat ?",
    "correct": "1",
    "incorrect": [
      "0",
      "2",
      "3"
    ]
  },
  {
    "question": "Dans quelle situation LOCATE() renverra-t-elle la valeur 1 ?",
    "correct": "Quand la chaîne recherchée commence dès le premier caractère",
    "incorrect": [
      "Quand la chaîne est vide",
      "Quand elle trouve plusieurs occurrences",
      "Quand la chaîne recherchée est plus longue"
    ]
  },
  {
    "question": "Quel est le résultat de LOCATE('mètre', 'mm') ?",
    "correct": "0",
    "incorrect": [
      "1",
      "NULL",
      "2"
    ]
  },
  {
    "question": "Quel est le rôle de la fonction SQL INSTR() ?",
    "correct": "Retourner la position d’une sous-chaîne dans une chaîne",
    "incorrect": [
      "Supprimer une sous-chaîne",
      "Concaténer deux chaînes",
      "Extraire une sous-chaîne"
    ]
  },
  {
    "question": "Quelle est la valeur de retour de INSTR('bonjour', 'jour') ?",
    "correct": "4",
    "incorrect": [
      "5",
      "3",
      "0"
    ]
  },
  {
    "question": "Que retourne INSTR('bonjour', 'soir') ?",
    "correct": "0",
    "incorrect": [
      "-1",
      "NULL",
      "1"
    ]
  },
  {
    "question": "Dans quel SGBD peut-on utiliser la fonction INSTR() ?",
    "correct": "MySQL et Oracle",
    "incorrect": [
      "PostgreSQL uniquement",
      "SQL Server uniquement",
      "Tous les SGBD sauf Oracle"
    ]
  },
  {
    "question": "Quelle est la différence principale entre INSTR() et LOCATE() ?",
    "correct": "L’ordre des paramètres est inversé",
    "incorrect": [
      "LOCATE() ne retourne jamais 0",
      "INSTR() remplace les chaînes",
      "INSTR() retourne toutes les occurrences"
    ]
  },
  {
    "question": "Que retourne INSTR('hello world!', 'world') ?",
    "correct": "7",
    "incorrect": [
      "6",
      "8",
      "1"
    ]
  },
  {
    "question": "Si une sous-chaîne apparaît plusieurs fois, que retourne INSTR() ?",
    "correct": "La position de la première occurrence",
    "incorrect": [
      "La position de la dernière occurrence",
      "Le nombre total d’occurrences",
      "Une erreur"
    ]
  },
  {
    "question": "Quelle requête permet de trouver si un mot contient 'er' ?",
    "correct": "SELECT INSTR(verbe, 'er') FROM verbe;",
    "incorrect": [
      "SELECT LOCATE('verbe', 'er') FROM verbe;",
      "SELECT REPLACE(verbe, 'er') FROM verbe;",
      "SELECT LENGTH(verbe, 'er') FROM verbe;"
    ]
  },
  {
    "question": "Quel est le résultat de INSTR('manger', 'er') ?",
    "correct": "5",
    "incorrect": [
      "6",
      "3",
      "0"
    ]
  },
  {
    "question": "Quel résultat retourne INSTR('avoir', 'er') ?",
    "correct": "0",
    "incorrect": [
      "1",
      "4",
      "5"
    ]
  },
  {
    "question": "Quelle fonction SQL retourne la valeur absolue d’un nombre ?",
    "correct": "ABS()",
    "incorrect": [
      "MOD()",
      "FLOOR()",
      "ROUND()"
    ]
  },
  {
    "question": "Quelle fonction permet de calculer la racine carrée en SQL ?",
    "correct": "SQRT()",
    "incorrect": [
      "POWER()",
      "CBRT()",
      "SQUARE()"
    ]
  },
  {
    "question": "Quelle fonction permet d’obtenir un nombre entier supérieur ?",
    "correct": "CEIL()",
    "incorrect": [
      "FLOOR()",
      "ROUND()",
      "TRUNCATE()"
    ]
  },
  {
    "question": "Quelle fonction permet de convertir des radians en degrés ?",
    "correct": "DEGREES()",
    "incorrect": [
      "RADIANS()",
      "LOG()",
      "PI()"
    ]
  },
  {
    "question": "Quelle fonction SQL retourne la valeur de PI ?",
    "correct": "PI()",
    "incorrect": [
      "EXP()",
      "POW()",
      "SQUARE()"
    ]
  },
  {
    "question": "Quelle fonction retourne un nombre aléatoire dans MySQL ?",
    "correct": "RAND()",
    "incorrect": [
      "RANDOM()",
      "SETSEED()",
      "ROUND()"
    ]
  },
  {
    "question": "Quelle fonction retourne le reste d’une division ?",
    "correct": "MOD()",
    "incorrect": [
      "DIV()",
      "ABS()",
      "SIGN()"
    ]
  },
  {
    "question": "Quelle fonction calcule le logarithme naturel ?",
    "correct": "LN()",
    "incorrect": [
      "LOG10()",
      "EXP()",
      "SQRT()"
    ]
  },
  {
    "question": "Quelle fonction permet de tronquer un nombre dans MySQL ?",
    "correct": "TRUNCATE()",
    "incorrect": [
      "ROUND()",
      "TRUNC()",
      "FLOOR()"
    ]
  },
  {
    "question": "Quelle fonction est utilisée pour convertir des degrés en radians ?",
    "correct": "RADIANS()",
    "incorrect": [
      "DEGREES()",
      "COS()",
      "PI()"
    ]
  },
  {
    "question": "Quelle fonction permet d’élever un nombre à une puissance ?",
    "correct": "POWER()",
    "incorrect": [
      "MOD()",
      "SQRT()",
      "CEILING()"
    ]
  },
  {
    "question": "Quelle fonction retourne le cosinus d’un nombre ?",
    "correct": "COS()",
    "incorrect": [
      "SIN()",
      "TAN()",
      "ACOS()"
    ]
  },
  {
    "question": "Quelle fonction permet d’arrondir un nombre à virgule ?",
    "correct": "ROUND()",
    "incorrect": [
      "FLOOR()",
      "TRUNCATE()",
      "ABS()"
    ]
  },
  {
    "question": "Quelle fonction permet d’obtenir un entier inférieur ou égal au nombre ?",
    "correct": "FLOOR()",
    "incorrect": [
      "CEIL()",
      "ROUND()",
      "MOD()"
    ]
  },
  {
    "question": "Quelle fonction retourne la tangente d’un nombre ?",
    "correct": "TAN()",
    "incorrect": [
      "SIN()",
      "COS()",
      "ATAN()"
    ]
  },
  {
    "question": "Quelle fonction permet de connaître si un nombre est positif ou négatif ?",
    "correct": "SIGN()",
    "incorrect": [
      "ABS()",
      "MOD()",
      "LOG()"
    ]
  },
  {
    "question": "Quelle fonction retourne l’exponentielle d’un nombre ?",
    "correct": "EXP()",
    "incorrect": [
      "LN()",
      "POWER()",
      "LOG()"
    ]
  },
  {
    "question": "Quelle fonction retourne l’arc sinus ?",
    "correct": "ASIN()",
    "incorrect": [
      "SIN()",
      "ATAN()",
      "ACOS()"
    ]
  },
  {
    "question": "Quelle fonction retourne le logarithme en base 10 ?",
    "correct": "LOG10()",
    "incorrect": [
      "LOG2()",
      "LOG()",
      "LN()"
    ]
  },
  {
    "question": "Quelle fonction retourne la racine cubique ?",
    "correct": "CBRT()",
    "incorrect": [
      "SQRT()",
      "SQUARE()",
      "POWER()"
    ]
  },
  {
    "question": "Quelle fonction retourne la cotangente ?",
    "correct": "COT()",
    "incorrect": [
      "TAN()",
      "COS()",
      "SIN()"
    ]
  },
  {
    "question": "Quelle fonction retourne l’arc tangente ?",
    "correct": "ATAN()",
    "incorrect": [
      "TAN()",
      "ACOS()",
      "ASIN()"
    ]
  },
  {
    "question": "Quelle fonction retourne une valeur de hachage CRC ?",
    "correct": "CRC32()",
    "incorrect": [
      "CONV()",
      "MOD()",
      "ABS()"
    ]
  },
  {
    "question": "Quelle fonction retourne un angle entre un axe et un rayon ?",
    "correct": "ATN2()",
    "incorrect": [
      "ATAN2()",
      "DEGREES()",
      "SIGN()"
    ]
  },
  {
    "question": "Quelle fonction convertit entre différentes bases numériques ?",
    "correct": "CONV()",
    "incorrect": [
      "LOG2()",
      "MOD()",
      "ROUND()"
    ]
  },
  {
    "question": "Quelle fonction retourne le sinus d’un nombre ?",
    "correct": "SIN()",
    "incorrect": [
      "COS()",
      "TAN()",
      "ASIN()"
    ]
  },
  {
    "question": "Quelle fonction retourne le logarithme base 2 ?",
    "correct": "LOG2()",
    "incorrect": [
      "LOG()",
      "LOG10()",
      "LN()"
    ]
  },
  {
    "question": "Quelle fonction permet d’utiliser une base aléatoire personnalisée sous PostgreSQL ?",
    "correct": "SETSEED()",
    "incorrect": [
      "RANDOM()",
      "RAND()",
      "PI()"
    ]
  },
  {
    "question": "Quelle fonction retourne une valeur aléatoire entre 0.0 et 1.0 sous PostgreSQL ?",
    "correct": "RANDOM()",
    "incorrect": [
      "RAND()",
      "ROUND()",
      "TRUNC()"
    ]
  },
  {
    "question": "Quelle fonction retourne le carré d’un nombre sous SQL Server ?",
    "correct": "SQUARE()",
    "incorrect": [
      "POW()",
      "POWER()",
      "SQRT()"
    ]
  },
  {
    "question": "Quelle fonction PostgreSQL tronque un nombre décimal ?",
    "correct": "TRUNC()",
    "incorrect": [
      "TRUNCATE()",
      "ROUND()",
      "FLOOR()"
    ]
  },
  {
    "question": "Quel est le rôle principal de la fonction SQL RAND() ?",
    "correct": "Générer un nombre aléatoire à virgule entre 0 et 1",
    "incorrect": [
      "Arrondir un nombre à l'entier le plus proche",
      "Générer un nombre entier entre 1 et 10",
      "Retourner un identifiant unique"
    ]
  },
  {
    "question": "Que retourne la fonction SQL RAND() lorsqu’on exécute SELECT RAND(); ?",
    "correct": "Un nombre flottant entre 0 et 1",
    "incorrect": [
      "Un entier entre 0 et 100",
      "Une chaîne aléatoire de caractères",
      "Un booléen aléatoire"
    ]
  },
  {
    "question": "Quelle est la bonne requête pour générer un nombre aléatoire entre 0 et 100 ?",
    "correct": "SELECT RAND() * 100;",
    "incorrect": [
      "SELECT RAND(100);",
      "SELECT RANDOM(0,100);",
      "SELECT 100 * RAND();"
    ]
  },
  {
    "question": "Pourquoi utiliser la fonction RAND() avec ORDER BY dans une requête ?",
    "correct": "Pour trier les résultats de manière aléatoire",
    "incorrect": [
      "Pour trier les résultats par ordre alphabétique",
      "Pour trier les résultats par identifiant",
      "Pour obtenir uniquement les lignes sans doublons"
    ]
  },
  {
    "question": "Quelle combinaison de fonctions permet de sélectionner une ligne aléatoire dans une table avec des identifiants de 1 à 10 ?",
    "correct": "ROUND(RAND() * 9) + 1",
    "incorrect": [
      "RAND(10) + 1",
      "FLOOR(RAND() * 10)",
      "RAND() % 10 + 1"
    ]
  },
  {
    "question": "Quel est le risque principal de la requête utilisant WHERE id = ROUND(RAND() * 9) + 1 ?",
    "correct": "Le risque de ne pas retourner de résultat si des identifiants manquent",
    "incorrect": [
      "Elle génère un identifiant négatif",
      "Elle retourne toujours le même enregistrement",
      "Elle modifie les données de la table"
    ]
  },
  {
    "question": "Que se passe-t-il si on exécute deux fois SELECT RAND(); ?",
    "correct": "On obtient deux résultats différents à chaque fois",
    "incorrect": [
      "La fonction retourne toujours le même résultat",
      "La fonction retourne un identifiant aléatoire",
      "Le résultat dépend de la clé primaire"
    ]
  },
  {
    "question": "Quelle est la limite supérieure du nombre retourné par RAND() ?",
    "correct": "1 (exclu)",
    "incorrect": [
      "10",
      "100",
      "Il n’y a pas de limite"
    ]
  },
  {
    "question": "Quel mot-clé SQL est couramment utilisé avec RAND() pour mélanger les résultats ?",
    "correct": "ORDER BY",
    "incorrect": [
      "GROUP BY",
      "HAVING",
      "DISTINCT"
    ]
  },
  {
    "question": "Quelle fonction doit-on combiner avec RAND() pour obtenir un entier ?",
    "correct": "ROUND()",
    "incorrect": [
      "FLOOR()",
      "ABS()",
      "TRUNCATE()"
    ]
  },
  {
    "question": "Quel est l’objectif principal de la fonction SQL ROUND() ?",
    "correct": "Arrondir un nombre numérique à un entier ou à un nombre de décimales donné",
    "incorrect": [
      "Convertir un nombre en chaîne de caractères",
      "Extraire la partie entière d’un nombre",
      "Calculer la racine carrée d’un nombre"
    ]
  },
  {
    "question": "Quelle syntaxe permet d’arrondir une colonne numérique sans décimale ?",
    "correct": "SELECT ROUND(nom_colonne) FROM table;",
    "incorrect": [
      "SELECT ROUND(nom_colonne, 1) FROM table;",
      "SELECT ROUND(nom_colonne, 2) FROM table;",
      "SELECT TRUNCATE(nom_colonne) FROM table;"
    ]
  },
  {
    "question": "Comment arrondir un nombre à 2 décimales avec ROUND() ?",
    "correct": "SELECT ROUND(nom_colonne, 2) FROM table;",
    "incorrect": [
      "SELECT ROUND(nom_colonne) FROM table;",
      "SELECT TRUNCATE(nom_colonne, 2) FROM table;",
      "SELECT ROUND(nom_colonne, -2) FROM table;"
    ]
  },
  {
    "question": "Que retourne ROUND(78.4216857) ?",
    "correct": "78",
    "incorrect": [
      "79",
      "78.42",
      "78.4217"
    ]
  },
  {
    "question": "Que retourne ROUND(78.4216857, 2) ?",
    "correct": "78.42",
    "incorrect": [
      "78.4",
      "78.43",
      "78"
    ]
  },
  {
    "question": "Comment arrondir un nombre à la dizaine la plus proche avec ROUND() ?",
    "correct": "ROUND(nombre, -1)",
    "incorrect": [
      "ROUND(nombre, 1)",
      "ROUND(nombre, 10)",
      "ROUND(nombre, 0)"
    ]
  },
  {
    "question": "Que signifie un second argument négatif dans la fonction ROUND() ?",
    "correct": "Arrondir à gauche de la virgule, par exemple dizaine, centaine",
    "incorrect": [
      "Arrondir à droite de la virgule",
      "Convertir un nombre en entier",
      "Multiplier par une puissance de 10"
    ]
  },
  {
    "question": "Que retourne ROUND(24.6578954, -1) ?",
    "correct": "20",
    "incorrect": [
      "24.6",
      "25",
      "30"
    ]
  },
  {
    "question": "Si le chiffre après la virgule est supérieur à 0.5, que fait ROUND() ?",
    "correct": "Arrondit au chiffre entier supérieur",
    "incorrect": [
      "Arrondit au chiffre entier inférieur",
      "Ignore la décimale",
      "Arrondit toujours vers zéro"
    ]
  },
  {
    "question": "Quel résultat obtient-on avec ROUND(63.5236241) ?",
    "correct": "64",
    "incorrect": [
      "63",
      "63.52",
      "63.5"
    ]
  },
  {
    "question": "Quelle fonction SQL permet de récupérer la date courante dans MySQL ?",
    "correct": "CURDATE()",
    "incorrect": [
      "NOW()",
      "CURRENT_TIME()",
      "GETDATE()"
    ]
  },
  {
    "question": "Quelle fonction retourne le nombre de jours entre deux dates en MySQL ?",
    "correct": "DATEDIFF()",
    "incorrect": [
      "DATE_SUB()",
      "DATE_ADD()",
      "DAYOFMONTH()"
    ]
  },
  {
    "question": "Comment extraire le mois d’une date dans MySQL ?",
    "correct": "MONTH()",
    "incorrect": [
      "DAY()",
      "YEAR()",
      "HOUR()"
    ]
  },
  {
    "question": "Quelle fonction PostgreSQL permet de soustraire deux dates ?",
    "correct": "AGE()",
    "incorrect": [
      "DATEDIFF()",
      "DATE_SUB()",
      "DATE_DIFF()"
    ]
  },
  {
    "question": "Quelle fonction SQL Server permet d’ajouter un intervalle à une date ?",
    "correct": "DATEADD()",
    "incorrect": [
      "DATE_ADD()",
      "TIMESTAMPADD()",
      "ADDDATE()"
    ]
  },
  {
    "question": "Que retourne la fonction DAYOFWEEK() en MySQL ?",
    "correct": "Le jour de la semaine (1 = dimanche, 2 = lundi, ...)",
    "incorrect": [
      "Le jour dans le mois",
      "Le jour dans l’année",
      "Le numéro de la semaine"
    ]
  },
  {
    "question": "Quelle fonction MySQL permet de convertir un timestamp UNIX en date au format DATETIME ?",
    "correct": "FROM_UNIXTIME()",
    "incorrect": [
      "UNIX_TIMESTAMP()",
      "STR_TO_DATE()",
      "TIMESTAMP()"
    ]
  },
  {
    "question": "Quelle fonction permet d’extraire le nom du mois en MySQL ?",
    "correct": "MONTHNAME()",
    "incorrect": [
      "DAYNAME()",
      "MONTH()",
      "DATE_FORMAT()"
    ]
  },
  {
    "question": "Quelle fonction MySQL permet d’ajouter une période sous forme d’heures à une date ?",
    "correct": "ADDDATE()",
    "incorrect": [
      "DATE_ADD()",
      "ADDTIME()",
      "DATE_SUB()"
    ]
  },
  {
    "question": "Comment formater une date selon un format spécifique en MySQL ?",
    "correct": "DATE_FORMAT()",
    "incorrect": [
      "FORMAT()",
      "STR_TO_DATE()",
      "CONVERT_TZ()"
    ]
  },
  {
    "question": "Que fait la fonction UNIX_TIMESTAMP() ?",
    "correct": "Retourne le nombre de secondes depuis le 1er janvier 1970",
    "incorrect": [
      "Retourne la date au format UNIX",
      "Retourne la date courante",
      "Convertit un timestamp en date"
    ]
  },
  {
    "question": "Quelle fonction retourne le dernier jour du mois d’une date ?",
    "correct": "LAST_DAY()",
    "incorrect": [
      "END_OF_MONTH()",
      "MONTH_END()",
      "DATE_TRUNC()"
    ]
  },
  {
    "question": "Quelle fonction retourne le numéro de la semaine dans une année à partir d’une date ?",
    "correct": "WEEK()",
    "incorrect": [
      "WEEKDAY()",
      "WEEKOFYEAR()",
      "YEARWEEK()"
    ]
  },
  {
    "question": "Que permet de faire la fonction TIMEDIFF() ?",
    "correct": "Retourner la durée entre deux heures",
    "incorrect": [
      "Additionner deux heures",
      "Extraire l’heure d’une date",
      "Soustraire une date d’une autre"
    ]
  },
  {
    "question": "Quelle fonction retourne la date et l’heure courantes en MySQL ?",
    "correct": "NOW()",
    "incorrect": [
      "CURDATE()",
      "CURRENT_DATE()",
      "SYSDATE()"
    ]
  },
  {
    "question": "Quelle fonction retourne le nombre d’heures dans une heure au format HH:MM:SS ?",
    "correct": "HOUR()",
    "incorrect": [
      "MINUTE()",
      "SECOND()",
      "TIME()"
    ]
  },
  {
    "question": "Comment extraire l’année d’une date en SQL Server ?",
    "correct": "YEAR()",
    "incorrect": [
      "DATEPART()",
      "DATEDIFF()",
      "MONTH()"
    ]
  },
  {
    "question": "Quelle fonction convertit une chaîne en date en MySQL ?",
    "correct": "STR_TO_DATE()",
    "incorrect": [
      "FROM_UNIXTIME()",
      "CONVERT_TZ()",
      "DATE_FORMAT()"
    ]
  },
  {
    "question": "Quelle fonction PostgreSQL permet de tronquer un DATETIME à une précision donnée ?",
    "correct": "DATE_TRUNC()",
    "incorrect": [
      "DATE_FORMAT()",
      "TRUNC()",
      "ROUND()"
    ]
  },
  {
    "question": "Quelle fonction retourne l’heure/minutes/secondes d’une date au format HH:MM:SS en MySQL ?",
    "correct": "TIME()",
    "incorrect": [
      "HOUR()",
      "MINUTE()",
      "SECOND()"
    ]
  },
  {
    "question": "Que fait la fonction CONVERT_TZ() en MySQL ?",
    "correct": "Convertit une date d’un fuseau horaire à un autre",
    "incorrect": [
      "Convertit un timestamp UNIX en date",
      "Formate une date",
      "Retourne la date UTC"
    ]
  },
  {
    "question": "Quelle fonction permet de récupérer la date et l’heure UTC en MySQL ?",
    "correct": "UTC_TIMESTAMP()",
    "incorrect": [
      "NOW()",
      "CURRENT_TIMESTAMP()",
      "GETUTCDATE()"
    ]
  },
  {
    "question": "Quel est le rôle de la fonction DATE_PART() en PostgreSQL ?",
    "correct": "Extraire une partie (jour, mois, heure) d’un DATETIME",
    "incorrect": [
      "Ajouter une période à une date",
      "Formater une date",
      "Retourner la date courante"
    ]
  },
  {
    "question": "Que fait la fonction DATE_SUB() en MySQL ?",
    "correct": "Soustrait une période de temps à une date",
    "incorrect": [
      "Ajoute une période de temps à une date",
      "Retourne la date courante",
      "Convertit un timestamp UNIX en date"
    ]
  },
  {
    "question": "Quelle fonction SQL Server permet de vérifier si une valeur est une date valide ?",
    "correct": "ISDATE()",
    "incorrect": [
      "VALIDATE_DATE()",
      "CHECKDATE()",
      "ISDATETIME()"
    ]
  },
  {
    "question": "Quelle fonction MySQL retourne le nom du jour de la semaine ?",
    "correct": "DAYNAME()",
    "incorrect": [
      "DAYOFWEEK()",
      "DAYOFMONTH()",
      "MONTHNAME()"
    ]
  },
  {
    "question": "Quelle fonction PostgreSQL retourne une valeur ajustée pour un intervalle horaire ?",
    "correct": "JUSTIFY_HOURS()",
    "incorrect": [
      "ADJUST_INTERVAL()",
      "SETSEED()",
      "TIMESTAMPDIFF()"
    ]
  },
  {
    "question": "Que fait la fonction MAKEDATE() en MySQL ?",
    "correct": "Retourne une date à partir d’une année et du numéro du jour dans cette année",
    "incorrect": [
      "Crée une heure à partir d’heures, minutes et secondes",
      "Convertit une chaîne en date",
      "Retourne la date courante"
    ]
  },
  {
    "question": "Quel est le rôle de la fonction TIME_TO_SEC() en MySQL ?",
    "correct": "Convertit une heure au format HH:MM:SS en nombre de secondes",
    "incorrect": [
      "Convertit un timestamp en heure",
      "Retourne la date courante",
      "Formate une heure"
    ]
  },
  {
    "question": "Quelle fonction MySQL permet d’obtenir le trimestre d’une date ?",
    "correct": "QUARTER()",
    "incorrect": [
      "MONTH()",
      "WEEK()",
      "DAYOFYEAR()"
    ]
  }
]